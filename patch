From e0662513589032ee15713a2aac3ef3f9ab742ed3 Mon Sep 17 00:00:00 2001
From: UzairQamarxyz <uzairq@xgrid.co>
Date: Tue, 27 Dec 2022 22:14:40 +0500
Subject: [PATCH 01/13] AdjacentTags

---
 config.def.h |  4 ++++
 dwm.c        | 58 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 62 insertions(+)

diff --git a/config.def.h b/config.def.h
index 9efa774..8d45ea7 100644
--- a/config.def.h
+++ b/config.def.h
@@ -85,6 +85,10 @@ static const Key keys[] = {
 	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
 	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
 	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
+	{ MODKEY,                       XK_Right,  viewnext,       {0} },
+	{ MODKEY,                       XK_Left,   viewprev,       {0} },
+	{ MODKEY|ShiftMask,             XK_Right,  tagtonext,      {0} },
+	{ MODKEY|ShiftMask,             XK_Left,   tagtoprev,      {0} },
 	TAGKEYS(                        XK_1,                      0)
 	TAGKEYS(                        XK_2,                      1)
 	TAGKEYS(                        XK_3,                      2)
diff --git a/dwm.c b/dwm.c
index a5e2a2b..82135ec 100644
--- a/dwm.c
+++ b/dwm.c
@@ -187,8 +187,10 @@ static void monocle(Monitor *m);
 static void motionnotify(XEvent *e);
 static void movemouse(const Arg *arg);
 static Client *nexttagged(Client *c);
+static unsigned int nexttag(void);
 static Client *nexttiled(Client *c);
 static void pop(Client *c);
+static unsigned int prevtag(void);
 static void propertynotify(XEvent *e);
 static void quit(const Arg *arg);
 static Monitor *recttomon(int x, int y, int w, int h);
@@ -212,6 +214,8 @@ static void sigchld(int unused);
 static void spawn(const Arg *arg);
 static void tag(const Arg *arg);
 static void tagmon(const Arg *arg);
+static void tagtonext(const Arg *arg);
+static void tagtoprev(const Arg *arg);
 static void tile(Monitor *m);
 static void togglebar(const Arg *arg);
 static void togglefloating(const Arg *arg);
@@ -231,6 +235,8 @@ static void updatetitle(Client *c);
 static void updatewindowtype(Client *c);
 static void updatewmhints(Client *c);
 static void view(const Arg *arg);
+static void viewnext(const Arg *arg);
+static void viewprev(const Arg *arg);
 static Client *wintoclient(Window w);
 static Monitor *wintomon(Window w);
 static int xerror(Display *dpy, XErrorEvent *ee);
@@ -1227,6 +1233,13 @@ nexttagged(Client *c) {
 	return walked;
 }
 
+unsigned int
+nexttag(void)
+{
+	unsigned int seltag = selmon->tagset[selmon->seltags];
+	return seltag == (1 << (LENGTH(tags) - 1)) ? 1 : seltag << 1;
+}
+
 Client *
 nexttiled(Client *c)
 {
@@ -1243,6 +1256,13 @@ pop(Client *c)
 	arrange(c->mon);
 }
 
+unsigned int
+prevtag(void)
+{
+	unsigned int seltag = selmon->tagset[selmon->seltags];
+	return seltag == 1 ? (1 << (LENGTH(tags) - 1)) : seltag >> 1;
+}
+
 void
 propertynotify(XEvent *e)
 {
@@ -1702,6 +1722,32 @@ tagmon(const Arg *arg)
 	sendmon(selmon->sel, dirtomon(arg->i));
 }
 
+void
+tagtonext(const Arg *arg)
+{
+	unsigned int tmp;
+
+	if (selmon->sel == NULL)
+		return;
+
+	tmp = nexttag();
+	tag(&(const Arg){.ui = tmp });
+	view(&(const Arg){.ui = tmp });
+}
+
+void
+tagtoprev(const Arg *arg)
+{
+	unsigned int tmp;
+
+	if (selmon->sel == NULL)
+		return;
+
+	tmp = prevtag();
+	tag(&(const Arg){.ui = tmp });
+	view(&(const Arg){.ui = tmp });
+}
+
 void
 tile(Monitor *m)
 {
@@ -2080,6 +2126,18 @@ view(const Arg *arg)
 	arrange(selmon);
 }
 
+void
+viewnext(const Arg *arg)
+{
+	view(&(const Arg){.ui = nexttag()});
+}
+
+void
+viewprev(const Arg *arg)
+{
+	view(&(const Arg){.ui = prevtag()});
+}
+ 
 Client *
 wintoclient(Window w)
 {
-- 
2.39.0


From 677def72845222bd42600e8c0dd7eba46fb7ae86 Mon Sep 17 00:00:00 2001
From: UzairQamarxyz <uzairq@xgrid.co>
Date: Tue, 27 Dec 2022 22:14:56 +0500
Subject: [PATCH 02/13] Autostart

---
 dwm.1 | 23 ++++++++++++++++
 dwm.c | 84 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 107 insertions(+)

diff --git a/dwm.1 b/dwm.1
index ddc8321..86e73f9 100644
--- a/dwm.1
+++ b/dwm.1
@@ -30,6 +30,14 @@ top left corner.  The tags which are applied to one or more windows are
 indicated with an empty square in the top left corner.
 .P
 dwm draws a small border around windows to indicate the focus state.
+.P
+On start, dwm can start additional programs that may be specified in two special
+shell scripts (see the FILES section below), autostart_blocking.sh and
+autostart.sh.  The former is executed first and dwm will wait for its
+termination before starting.  The latter is executed in the background before
+dwm enters its handler loop.
+.P
+Either of these files may be omitted.
 .SH OPTIONS
 .TP
 .B \-v
@@ -152,6 +160,21 @@ Toggles focused window between floating and tiled state.
 .TP
 .B Mod1\-Button3
 Resize focused window while dragging. Tiled windows will be toggled to the floating state.
+.SH FILES
+The files containing programs to be started along with dwm are searched for in
+the following directories:
+.IP "1. $XDG_DATA_HOME/dwm"
+.IP "2. $HOME/.local/share/dwm"
+.IP "3. $HOME/.dwm"
+.P
+The first existing directory is scanned for any of the autostart files below.
+.TP 15
+autostart.sh
+This file is started as a shell background process before dwm enters its handler
+loop.
+.TP 15
+autostart_blocking.sh
+This file is started before any autostart.sh; dwm waits for its termination.
 .SH CUSTOMIZATION
 dwm is customized by creating a custom config.h and (re)compiling the source
 code. This keeps it fast, secure and simple.
diff --git a/dwm.c b/dwm.c
index 82135ec..5c5ab6b 100644
--- a/dwm.c
+++ b/dwm.c
@@ -29,6 +29,7 @@
 #include <string.h>
 #include <unistd.h>
 #include <sys/types.h>
+#include <sys/stat.h>
 #include <sys/wait.h>
 #include <X11/cursorfont.h>
 #include <X11/keysym.h>
@@ -199,6 +200,7 @@ static void resizeclient(Client *c, int x, int y, int w, int h);
 static void resizemouse(const Arg *arg);
 static void restack(Monitor *m);
 static void run(void);
+static void runautostart(void);
 static void scan(void);
 static int sendevent(Client *c, Atom proto);
 static void sendmon(Client *c, Monitor *m);
@@ -245,7 +247,11 @@ static int xerrorstart(Display *dpy, XErrorEvent *ee);
 static void zoom(const Arg *arg);
 
 /* variables */
+static const char autostartblocksh[] = "autostart_blocking.sh";
+static const char autostartsh[] = "autostart.sh";
 static const char broken[] = "broken";
+static const char dwmdir[] = "dwm";
+static const char localshare[] = ".local/share";
 static char stext[256];
 static int screen;
 static int sw, sh;           /* X display screen geometry width, height */
@@ -1435,6 +1441,83 @@ run(void)
 			handler[ev.type](&ev); /* call handler */
 }
 
+void
+runautostart(void)
+{
+	char *pathpfx;
+	char *path;
+	char *xdgdatahome;
+	char *home;
+	struct stat sb;
+
+	if ((home = getenv("HOME")) == NULL)
+		/* this is almost impossible */
+		return;
+
+	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
+	 * otherwise use ~/.local/share/dwm as autostart script directory
+	 */
+	xdgdatahome = getenv("XDG_DATA_HOME");
+	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
+		/* space for path segments, separators and nul */
+		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
+
+		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
+			free(pathpfx);
+			return;
+		}
+	} else {
+		/* space for path segments, separators and nul */
+		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
+		                     + strlen(dwmdir) + 3);
+
+		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
+			free(pathpfx);
+			return;
+		}
+	}
+
+	/* check if the autostart script directory exists */
+	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
+		/* the XDG conformant path does not exist or is no directory
+		 * so we try ~/.dwm instead
+		 */
+		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
+		if(pathpfx_new == NULL) {
+			free(pathpfx);
+			return;
+		}
+		pathpfx = pathpfx_new;
+
+		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
+			free(pathpfx);
+			return;
+		}
+	}
+
+	/* try the blocking script first */
+	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
+	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
+		free(path);
+		free(pathpfx);
+	}
+
+	if (access(path, X_OK) == 0)
+		system(path);
+
+	/* now the non-blocking script */
+	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
+		free(path);
+		free(pathpfx);
+	}
+
+	if (access(path, X_OK) == 0)
+		system(strcat(path, " &"));
+
+	free(pathpfx);
+	free(path);
+}
+
 void
 scan(void)
 {
@@ -2234,6 +2317,7 @@ main(int argc, char *argv[])
 		die("pledge");
 #endif /* __OpenBSD__ */
 	scan();
+	runautostart();
 	run();
 	cleanup();
 	XCloseDisplay(dpy);
-- 
2.39.0


From a62c5236d9d7a831aaf2482d5051b237d8eaccbf Mon Sep 17 00:00:00 2001
From: UzairQamarxyz <uzairq@xgrid.co>
Date: Tue, 27 Dec 2022 22:15:13 +0500
Subject: [PATCH 03/13] Center

---
 config.def.h |  6 +++---
 dwm.c        | 13 +++++++++++--
 2 files changed, 14 insertions(+), 5 deletions(-)

diff --git a/config.def.h b/config.def.h
index 8d45ea7..33b629c 100644
--- a/config.def.h
+++ b/config.def.h
@@ -26,9 +26,9 @@ static const Rule rules[] = {
 	 *	WM_CLASS(STRING) = instance, class
 	 *	WM_NAME(STRING) = title
 	 */
-	/* class      instance    title       tags mask     isfloating   monitor */
-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
-	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
+	/* class      instance    title       tags mask     iscentered   isfloating   monitor */
+	{ "Gimp",     NULL,       NULL,       0,            0,           1,           -1 },
+	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           0,           -1 },
 };
 
 /* layout(s) */
diff --git a/dwm.c b/dwm.c
index 5c5ab6b..3ccccad 100644
--- a/dwm.c
+++ b/dwm.c
@@ -94,7 +94,7 @@ struct Client {
 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
 	int bw, oldbw;
 	unsigned int tags;
-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
+	int isfixed, iscentered, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
 	Client *next;
 	Client *snext;
 	Monitor *mon;
@@ -139,6 +139,7 @@ typedef struct {
 	const char *instance;
 	const char *title;
 	unsigned int tags;
+	int iscentered;
 	int isfloating;
 	int monitor;
 } Rule;
@@ -301,6 +302,7 @@ applyrules(Client *c)
 	XClassHint ch = { NULL, NULL };
 
 	/* rule matching */
+	c->iscentered = 0;
 	c->isfloating = 0;
 	c->tags = 0;
 	XGetClassHint(dpy, c->win, &ch);
@@ -313,6 +315,7 @@ applyrules(Client *c)
 		&& (!r->class || strstr(class, r->class))
 		&& (!r->instance || strstr(instance, r->instance)))
 		{
+			c->iscentered = r->iscentered;
 			c->isfloating = r->isfloating;
 			c->tags |= r->tags;
 			for (m = mons; m && m->num != r->monitor; m = m->next);
@@ -1095,6 +1098,10 @@ manage(Window w, XWindowAttributes *wa)
 	updatewindowtype(c);
 	updatesizehints(c);
 	updatewmhints(c);
+	if (c->iscentered) {
+		c->x = c->mon->mx + (c->mon->mw - WIDTH(c)) / 2;
+		c->y = c->mon->my + (c->mon->mh - HEIGHT(c)) / 2;
+	}
 	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
 	grabbuttons(c, 0);
 	if (!c->isfloating)
@@ -2174,8 +2181,10 @@ updatewindowtype(Client *c)
 
 	if (state == netatom[NetWMFullscreen])
 		setfullscreen(c, 1);
-	if (wtype == netatom[NetWMWindowTypeDialog])
+	if (wtype == netatom[NetWMWindowTypeDialog]) {
+		c->iscentered = 1;
 		c->isfloating = 1;
+	}
 }
 
 void
-- 
2.39.0


From 28652259cc83b65c1ea241dfae22943808b5b8c0 Mon Sep 17 00:00:00 2001
From: UzairQamarxyz <uzairq@xgrid.co>
Date: Tue, 27 Dec 2022 22:15:34 +0500
Subject: [PATCH 04/13] Alpha Border Fix

---
 drw.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/drw.c b/drw.c
index a58a2b4..163eb51 100644
--- a/drw.c
+++ b/drw.c
@@ -190,6 +190,8 @@ drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
 	                       DefaultColormap(drw->dpy, drw->screen),
 	                       clrname, dest))
 		die("error, cannot allocate color '%s'", clrname);
+
+	dest->pixel |= 0xff << 24;
 }
 
 /* Wrapper to create color schemes. The caller has to call free(3) on the
-- 
2.39.0


From 85f432e1978308627910d7c2bd6683af357811fe Mon Sep 17 00:00:00 2001
From: UzairQamarxyz <uzairq@xgrid.co>
Date: Tue, 27 Dec 2022 22:16:33 +0500
Subject: [PATCH 05/13] Full Gaps

---
 config.def.h |  1 +
 dwm.1        | 10 ++++++++++
 dwm.c        | 22 ++++++++++++----------
 3 files changed, 23 insertions(+), 10 deletions(-)

diff --git a/config.def.h b/config.def.h
index 33b629c..e878f94 100644
--- a/config.def.h
+++ b/config.def.h
@@ -2,6 +2,7 @@
 
 /* appearance */
 static const unsigned int borderpx  = 1;        /* border pixel of windows */
+static const unsigned int gappx     = 5;        /* gaps between windows */
 static const unsigned int snap      = 32;       /* snap pixel */
 static const int showbar            = 1;        /* 0 means no bar */
 static const int topbar             = 1;        /* 0 means bottom bar */
diff --git a/dwm.1 b/dwm.1
index 86e73f9..e20d0db 100644
--- a/dwm.1
+++ b/dwm.1
@@ -148,6 +148,16 @@ View all windows with any tag.
 .B Mod1\-Control\-[1..n]
 Add/remove all windows with nth tag to/from the view.
 .TP
+.B Mod1\--
+Decrease the gaps around windows.
+.TP
+.B Mod1\-=
+Increase the gaps around windows.
+.TP
+.B Mod1\-Shift-=
+Reset the gaps around windows to
+.BR 0 .
+.TP
 .B Mod1\-Shift\-q
 Quit dwm.
 .SS Mouse commands
diff --git a/dwm.c b/dwm.c
index 3ccccad..b8d163b 100644
--- a/dwm.c
+++ b/dwm.c
@@ -121,6 +121,7 @@ struct Monitor {
 	int by;               /* bar geometry */
 	int mx, my, mw, mh;   /* screen size */
 	int wx, wy, ww, wh;   /* window area  */
+	int gappx;            /* gaps between windows */
 	unsigned int seltags;
 	unsigned int sellt;
 	unsigned int tagset[2];
@@ -671,6 +672,7 @@ createmon(void)
 	m->nmaster = nmaster;
 	m->showbar = showbar;
 	m->topbar = topbar;
+	m->gappx = gappx;
 	m->lt[0] = &layouts[0];
 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
@@ -1851,18 +1853,18 @@ tile(Monitor *m)
 	if (n > m->nmaster)
 		mw = m->nmaster ? m->ww * m->mfact : 0;
 	else
-		mw = m->ww;
-	for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		mw = m->ww - m->gappx;
+	for (i = 0, my = ty = m->gappx, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
 		if (i < m->nmaster) {
-			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
-			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
-			if (my + HEIGHT(c) < m->wh)
-				my += HEIGHT(c);
+			h = (m->wh - my) / (MIN(n, m->nmaster) - i) - m->gappx;
+			resize(c, m->wx + m->gappx, m->wy + my, mw - (2*c->bw) - m->gappx, h - (2*c->bw), 0);
+			if (my + HEIGHT(c) + m->gappx < m->wh)
+				my += HEIGHT(c) + m->gappx;
 		} else {
-			h = (m->wh - ty) / (n - i);
-			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
-			if (ty + HEIGHT(c) < m->wh)
-				ty += HEIGHT(c);
+			h = (m->wh - ty) / (n - i) - m->gappx;
+			resize(c, m->wx + mw + m->gappx, m->wy + ty, m->ww - mw - (2*c->bw) - 2*m->gappx, h - (2*c->bw), 0);
+			if (ty + HEIGHT(c) + m->gappx < m->wh)
+				ty += HEIGHT(c) + m->gappx;
 		}
 }
 
-- 
2.39.0


From 9e24c169bf238c816ea897cc1a69341fa54d381d Mon Sep 17 00:00:00 2001
From: UzairQamarxyz <uzairq@xgrid.co>
Date: Tue, 27 Dec 2022 22:17:04 +0500
Subject: [PATCH 06/13] No Title

---
 config.def.h |  1 -
 dwm.c        | 20 ++++----------------
 2 files changed, 4 insertions(+), 17 deletions(-)

diff --git a/config.def.h b/config.def.h
index e878f94..0444aaa 100644
--- a/config.def.h
+++ b/config.def.h
@@ -108,7 +108,6 @@ static const Button buttons[] = {
 	/* click                event mask      button          function        argument */
 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
-	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
 	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
diff --git a/dwm.c b/dwm.c
index b8d163b..9460579 100644
--- a/dwm.c
+++ b/dwm.c
@@ -66,8 +66,8 @@ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
        NetWMFullscreen, NetActiveWindow, NetWMWindowType,
        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
 enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
-enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
-       ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
+enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
+       ClkRootWin, ClkLast }; /* clicks */
 
 typedef union {
 	int i;
@@ -472,10 +472,8 @@ buttonpress(XEvent *e)
 			arg.ui = 1 << i;
 		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
 			click = ClkLtSymbol;
-		else if (ev->x > selmon->ww - (int)TEXTW(stext))
-			click = ClkStatusText;
 		else
-			click = ClkWinTitle;
+			click = ClkStatusText;
 	} else if ((c = wintoclient(ev->window))) {
 		focus(c);
 		restack(selmon);
@@ -767,15 +765,8 @@ drawbar(Monitor *m)
 	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
 
 	if ((w = m->ww - tw - x) > bh) {
-		if (m->sel) {
-			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
-			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
-			if (m->sel->isfloating)
-				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
-		} else {
 			drw_setscheme(drw, scheme[SchemeNorm]);
 			drw_rect(drw, x, 0, w, bh, 1, 1);
-		}
 	}
 	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
 }
@@ -1305,11 +1296,8 @@ propertynotify(XEvent *e)
 			drawbars();
 			break;
 		}
-		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]) {
+		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName])
 			updatetitle(c);
-			if (c == c->mon->sel)
-				drawbar(c->mon);
-		}
 		if (ev->atom == netatom[NetWMWindowType])
 			updatewindowtype(c);
 	}
-- 
2.39.0


From 60707f07ce1b9068a9afdf296d26b5f59206056a Mon Sep 17 00:00:00 2001
From: UzairQamarxyz <uzairq@xgrid.co>
Date: Tue, 27 Dec 2022 22:17:20 +0500
Subject: [PATCH 07/13] Per Tag

---
 dwm.c | 88 +++++++++++++++++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 82 insertions(+), 6 deletions(-)

diff --git a/dwm.c b/dwm.c
index 9460579..f277ed6 100644
--- a/dwm.c
+++ b/dwm.c
@@ -113,6 +113,7 @@ typedef struct {
 	void (*arrange)(Monitor *);
 } Layout;
 
+typedef struct Pertag Pertag;
 struct Monitor {
 	char ltsymbol[16];
 	float mfact;
@@ -133,6 +134,7 @@ struct Monitor {
 	Monitor *next;
 	Window barwin;
 	const Layout *lt[2];
+	Pertag *pertag;
 };
 
 typedef struct {
@@ -289,6 +291,15 @@ static Window root, wmcheckwin;
 /* configuration, allows nested code to access above variables */
 #include "config.h"
 
+struct Pertag {
+	unsigned int curtag, prevtag; /* current and previous tag */
+	int nmasters[LENGTH(tags) + 1]; /* number of windows in master area */
+	float mfacts[LENGTH(tags) + 1]; /* mfacts per tag */
+	unsigned int sellts[LENGTH(tags) + 1]; /* selected layouts */
+	const Layout *ltidxs[LENGTH(tags) + 1][2]; /* matrix of tags and layouts indexes  */
+	int showbars[LENGTH(tags) + 1]; /* display bar for the current tag */
+};
+
 /* compile-time check if all tags fit into an unsigned int bit array. */
 struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
 
@@ -663,6 +674,7 @@ Monitor *
 createmon(void)
 {
 	Monitor *m;
+	unsigned int i;
 
 	m = ecalloc(1, sizeof(Monitor));
 	m->tagset[0] = m->tagset[1] = 1;
@@ -674,6 +686,20 @@ createmon(void)
 	m->lt[0] = &layouts[0];
 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
+	m->pertag = ecalloc(1, sizeof(Pertag));
+	m->pertag->curtag = m->pertag->prevtag = 1;
+
+	for (i = 0; i <= LENGTH(tags); i++) {
+		m->pertag->nmasters[i] = m->nmaster;
+		m->pertag->mfacts[i] = m->mfact;
+
+		m->pertag->ltidxs[i][0] = m->lt[0];
+		m->pertag->ltidxs[i][1] = m->lt[1];
+		m->pertag->sellts[i] = m->sellt;
+
+		m->pertag->showbars[i] = m->showbar;
+	}
+
 	return m;
 }
 
@@ -1003,7 +1029,7 @@ grabkeys(void)
 void
 incnmaster(const Arg *arg)
 {
-	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
+	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag] = MAX(selmon->nmaster + arg->i, 0);
 	arrange(selmon);
 }
 
@@ -1636,9 +1662,9 @@ void
 setlayout(const Arg *arg)
 {
 	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
-		selmon->sellt ^= 1;
+		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag] ^= 1;
 	if (arg && arg->v)
-		selmon->lt[selmon->sellt] = (Layout *)arg->v;
+		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt] = (Layout *)arg->v;
 	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
 	if (selmon->sel)
 		arrange(selmon);
@@ -1657,7 +1683,7 @@ setmfact(const Arg *arg)
 	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
 	if (f < 0.05 || f > 0.95)
 		return;
-	selmon->mfact = f;
+	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag] = f;
 	arrange(selmon);
 }
 
@@ -1859,7 +1885,7 @@ tile(Monitor *m)
 void
 togglebar(const Arg *arg)
 {
-	selmon->showbar = !selmon->showbar;
+	selmon->showbar = selmon->pertag->showbars[selmon->pertag->curtag] = !selmon->showbar;
 	updatebarpos(selmon);
 	XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
 	arrange(selmon);
@@ -1898,9 +1924,33 @@ void
 toggleview(const Arg *arg)
 {
 	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
+	int i;
 
 	if (newtagset) {
 		selmon->tagset[selmon->seltags] = newtagset;
+
+		if (newtagset == ~0) {
+			selmon->pertag->prevtag = selmon->pertag->curtag;
+			selmon->pertag->curtag = 0;
+		}
+
+		/* test if the user did not select the same tag */
+		if (!(newtagset & 1 << (selmon->pertag->curtag - 1))) {
+			selmon->pertag->prevtag = selmon->pertag->curtag;
+			for (i = 0; !(newtagset & 1 << i); i++) ;
+			selmon->pertag->curtag = i + 1;
+		}
+
+		/* apply settings for this view */
+		selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
+		selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
+		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
+		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
+		selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
+
+		if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
+			togglebar(NULL);
+
 		focus(NULL);
 		arrange(selmon);
 	}
@@ -2199,11 +2249,37 @@ updatewmhints(Client *c)
 void
 view(const Arg *arg)
 {
+	int i;
+	unsigned int tmptag;
+
 	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
 		return;
 	selmon->seltags ^= 1; /* toggle sel tagset */
-	if (arg->ui & TAGMASK)
+	if (arg->ui & TAGMASK) {
 		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
+		selmon->pertag->prevtag = selmon->pertag->curtag;
+
+		if (arg->ui == ~0)
+			selmon->pertag->curtag = 0;
+		else {
+			for (i = 0; !(arg->ui & 1 << i); i++) ;
+			selmon->pertag->curtag = i + 1;
+		}
+	} else {
+		tmptag = selmon->pertag->prevtag;
+		selmon->pertag->prevtag = selmon->pertag->curtag;
+		selmon->pertag->curtag = tmptag;
+	}
+
+	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
+	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
+	selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
+	selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
+	selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
+
+	if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
+		togglebar(NULL);
+
 	focus(NULL);
 	arrange(selmon);
 }
-- 
2.39.0


From 6d663ac2e4ed2b3944f7c2f11cfbd96c7ab5b0e0 Mon Sep 17 00:00:00 2001
From: UzairQamarxyz <uzairq@xgrid.co>
Date: Tue, 27 Dec 2022 22:17:47 +0500
Subject: [PATCH 08/13] Restart Signal

---
 config.def.h |  1 +
 dwm.1        | 10 ++++++++++
 dwm.c        | 22 ++++++++++++++++++++++
 3 files changed, 33 insertions(+)

diff --git a/config.def.h b/config.def.h
index 0444aaa..e3c4a5e 100644
--- a/config.def.h
+++ b/config.def.h
@@ -100,6 +100,7 @@ static const Key keys[] = {
 	TAGKEYS(                        XK_8,                      7)
 	TAGKEYS(                        XK_9,                      8)
 	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
+	{ MODKEY|ControlMask|ShiftMask, XK_q,      quit,           {1} }, 
 };
 
 /* button definitions */
diff --git a/dwm.1 b/dwm.1
index e20d0db..8466ea1 100644
--- a/dwm.1
+++ b/dwm.1
@@ -160,6 +160,9 @@ Reset the gaps around windows to
 .TP
 .B Mod1\-Shift\-q
 Quit dwm.
+.TP
+.B Mod1\-Control\-Shift\-q
+Restart dwm.
 .SS Mouse commands
 .TP
 .B Mod1\-Button1
@@ -188,6 +191,13 @@ This file is started before any autostart.sh; dwm waits for its termination.
 .SH CUSTOMIZATION
 dwm is customized by creating a custom config.h and (re)compiling the source
 code. This keeps it fast, secure and simple.
+.SH SIGNALS
+.TP
+.B SIGHUP - 1
+Restart the dwm process.
+.TP
+.B SIGTERM - 15
+Cleanly terminate the dwm process.
 .SH SEE ALSO
 .BR dmenu (1),
 .BR st (1)
diff --git a/dwm.c b/dwm.c
index f277ed6..065d595 100644
--- a/dwm.c
+++ b/dwm.c
@@ -217,6 +217,8 @@ static void setup(void);
 static void seturgent(Client *c, int urg);
 static void showhide(Client *c);
 static void sigchld(int unused);
+static void sighup(int unused);
+static void sigterm(int unused);
 static void spawn(const Arg *arg);
 static void tag(const Arg *arg);
 static void tagmon(const Arg *arg);
@@ -280,6 +282,7 @@ static void (*handler[LASTEvent]) (XEvent *) = {
 	[UnmapNotify] = unmapnotify
 };
 static Atom wmatom[WMLast], netatom[NetLast];
+static int restart = 0;
 static int running = 1;
 static Cur *cursor[CurLast];
 static Clr **scheme;
@@ -1332,6 +1335,7 @@ propertynotify(XEvent *e)
 void
 quit(const Arg *arg)
 {
+	if(arg->i) restart = 1;
 	running = 0;
 }
 
@@ -1697,6 +1701,9 @@ setup(void)
 	/* clean up any zombies immediately */
 	sigchld(0);
 
+	signal(SIGHUP, sighup);
+	signal(SIGTERM, sigterm);
+
 	/* init screen */
 	screen = DefaultScreen(dpy);
 	sw = DisplayWidth(dpy, screen);
@@ -1796,6 +1803,20 @@ sigchld(int unused)
 	while (0 < waitpid(-1, NULL, WNOHANG));
 }
 
+void
+sighup(int unused)
+{
+	Arg a = {.i = 1};
+	quit(&a);
+}
+
+void
+sigterm(int unused)
+{
+	Arg a = {.i = 0};
+	quit(&a);
+}
+
 void
 spawn(const Arg *arg)
 {
@@ -2394,6 +2415,7 @@ main(int argc, char *argv[])
 	scan();
 	runautostart();
 	run();
+	if(restart) execvp(argv[0], argv);
 	cleanup();
 	XCloseDisplay(dpy);
 	return EXIT_SUCCESS;
-- 
2.39.0


From bd64f96e2fd14349ec346052c50698ee2f03fd5e Mon Sep 17 00:00:00 2001
From: UzairQamarxyz <uzairq@xgrid.co>
Date: Tue, 27 Dec 2022 22:18:37 +0500
Subject: [PATCH 09/13] Status 2d

---
 dwm.c | 120 +++++++++++++++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 114 insertions(+), 6 deletions(-)

diff --git a/dwm.c b/dwm.c
index 065d595..1a94ca6 100644
--- a/dwm.c
+++ b/dwm.c
@@ -170,6 +170,7 @@ static void detachstack(Client *c);
 static Monitor *dirtomon(int dir);
 static void drawbar(Monitor *m);
 static void drawbars(void);
+static int drawstatusbar(Monitor *m, int bh, char* text);
 static void enternotify(XEvent *e);
 static void expose(XEvent *e);
 static void focus(Client *c);
@@ -258,7 +259,7 @@ static const char autostartsh[] = "autostart.sh";
 static const char broken[] = "broken";
 static const char dwmdir[] = "dwm";
 static const char localshare[] = ".local/share";
-static char stext[256];
+static char stext[1024];
 static int screen;
 static int sw, sh;           /* X display screen geometry width, height */
 static int bh;               /* bar height */
@@ -529,7 +530,7 @@ cleanup(void)
 		cleanupmon(mons);
 	for (i = 0; i < CurLast; i++)
 		drw_cur_free(drw, cursor[i]);
-	for (i = 0; i < LENGTH(colors); i++)
+	for (i = 0; i < LENGTH(colors) + 1; i++)
 		free(scheme[i]);
 	free(scheme);
 	XDestroyWindow(dpy, wmcheckwin);
@@ -754,6 +755,114 @@ dirtomon(int dir)
 	return m;
 }
 
+int
+drawstatusbar(Monitor *m, int bh, char* stext) {
+	int ret, i, w, x, len;
+	short isCode = 0;
+	char *text;
+	char *p;
+
+	len = strlen(stext) + 1 ;
+	if (!(text = (char*) malloc(sizeof(char)*len)))
+		die("malloc");
+	p = text;
+	memcpy(text, stext, len);
+
+	/* compute width of the status text */
+	w = 0;
+	i = -1;
+	while (text[++i]) {
+		if (text[i] == '^') {
+			if (!isCode) {
+				isCode = 1;
+				text[i] = '\0';
+				w += TEXTW(text) - lrpad;
+				text[i] = '^';
+				if (text[++i] == 'f')
+					w += atoi(text + ++i);
+			} else {
+				isCode = 0;
+				text = text + i + 1;
+				i = -1;
+			}
+		}
+	}
+	if (!isCode)
+		w += TEXTW(text) - lrpad;
+	else
+		isCode = 0;
+	text = p;
+
+	w += 2; /* 1px padding on both sides */
+	ret = x = m->ww - w;
+
+	drw_setscheme(drw, scheme[LENGTH(colors)]);
+	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+	drw_rect(drw, x, 0, w, bh, 1, 1);
+	x++;
+
+	/* process status text */
+	i = -1;
+	while (text[++i]) {
+		if (text[i] == '^' && !isCode) {
+			isCode = 1;
+
+			text[i] = '\0';
+			w = TEXTW(text) - lrpad;
+			drw_text(drw, x, 0, w, bh, 0, text, 0);
+
+			x += w;
+
+			/* process code */
+			while (text[++i] != '^') {
+				if (text[i] == 'c') {
+					char buf[8];
+					memcpy(buf, (char*)text+i+1, 7);
+					buf[7] = '\0';
+					drw_clr_create(drw, &drw->scheme[ColFg], buf);
+					i += 7;
+				} else if (text[i] == 'b') {
+					char buf[8];
+					memcpy(buf, (char*)text+i+1, 7);
+					buf[7] = '\0';
+					drw_clr_create(drw, &drw->scheme[ColBg], buf);
+					i += 7;
+				} else if (text[i] == 'd') {
+					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+				} else if (text[i] == 'r') {
+					int rx = atoi(text + ++i);
+					while (text[++i] != ',');
+					int ry = atoi(text + ++i);
+					while (text[++i] != ',');
+					int rw = atoi(text + ++i);
+					while (text[++i] != ',');
+					int rh = atoi(text + ++i);
+
+					drw_rect(drw, rx + x, ry, rw, rh, 1, 0);
+				} else if (text[i] == 'f') {
+					x += atoi(text + ++i);
+				}
+			}
+
+			text = text + i + 1;
+			i=-1;
+			isCode = 0;
+		}
+	}
+
+	if (!isCode) {
+		w = TEXTW(text) - lrpad;
+		drw_text(drw, x, 0, w, bh, 0, text, 0);
+	}
+
+	drw_setscheme(drw, scheme[SchemeNorm]);
+	free(p);
+
+	return ret;
+}
+
 void
 drawbar(Monitor *m)
 {
@@ -768,9 +877,7 @@ drawbar(Monitor *m)
 
 	/* draw status first so it can be overdrawn by tags later */
 	if (m == selmon) { /* status is only drawn on selected monitor */
-		drw_setscheme(drw, scheme[SchemeNorm]);
-		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
-		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
+		tw = m->ww - drawstatusbar(m, bh, stext);
 	}
 
 	for (c = m->clients; c; c = c->next) {
@@ -1735,7 +1842,8 @@ setup(void)
 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
 	/* init appearance */
-	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
+	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
+	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
 	for (i = 0; i < LENGTH(colors); i++)
 		scheme[i] = drw_scm_create(drw, colors[i], 3);
 	/* init bars */
-- 
2.39.0


From 24d3e3d85e7ddcfaa3ddf2b76f857622637f448a Mon Sep 17 00:00:00 2001
From: UzairQamarxyz <uzairq@xgrid.co>
Date: Tue, 27 Dec 2022 22:19:31 +0500
Subject: [PATCH 10/13] xrdb

---
 config.def.h | 22 ++++++++++---------
 drw.c        |  2 +-
 drw.h        |  2 +-
 dwm.c        | 62 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 76 insertions(+), 12 deletions(-)

diff --git a/config.def.h b/config.def.h
index e3c4a5e..f2bb3cc 100644
--- a/config.def.h
+++ b/config.def.h
@@ -8,15 +8,16 @@ static const int showbar            = 1;        /* 0 means no bar */
 static const int topbar             = 1;        /* 0 means bottom bar */
 static const char *fonts[]          = { "monospace:size=10" };
 static const char dmenufont[]       = "monospace:size=10";
-static const char col_gray1[]       = "#222222";
-static const char col_gray2[]       = "#444444";
-static const char col_gray3[]       = "#bbbbbb";
-static const char col_gray4[]       = "#eeeeee";
-static const char col_cyan[]        = "#005577";
-static const char *colors[][3]      = {
-	/*               fg         bg         border   */
-	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
-	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
+static char normbgcolor[]           = "#222222";
+static char normbordercolor[]       = "#444444";
+static char normfgcolor[]           = "#bbbbbb";
+static char selfgcolor[]            = "#eeeeee";
+static char selbordercolor[]        = "#005577";
+static char selbgcolor[]            = "#005577";
+static char *colors[][3] = {
+       /*               fg           bg           border   */
+       [SchemeNorm] = { normfgcolor, normbgcolor, normbordercolor },
+       [SchemeSel]  = { selfgcolor,  selbgcolor,  selbordercolor  },
 };
 
 /* tagging */
@@ -58,7 +59,7 @@ static const Layout layouts[] = {
 
 /* commands */
 static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbordercolor, "-sf", selfgcolor, NULL };
 static const char *termcmd[]  = { "st", NULL };
 
 static const Key keys[] = {
@@ -86,6 +87,7 @@ static const Key keys[] = {
 	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
 	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
 	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
+	{ MODKEY,                       XK_F5,     xrdb,           {.v = NULL } },
 	{ MODKEY,                       XK_Right,  viewnext,       {0} },
 	{ MODKEY,                       XK_Left,   viewprev,       {0} },
 	{ MODKEY|ShiftMask,             XK_Right,  tagtonext,      {0} },
diff --git a/drw.c b/drw.c
index 163eb51..7a00e1a 100644
--- a/drw.c
+++ b/drw.c
@@ -197,7 +197,7 @@ drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
 /* Wrapper to create color schemes. The caller has to call free(3) on the
  * returned color scheme when done using it. */
 Clr *
-drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
+drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount)
 {
 	size_t i;
 	Clr *ret;
diff --git a/drw.h b/drw.h
index 6471431..bdbf950 100644
--- a/drw.h
+++ b/drw.h
@@ -40,7 +40,7 @@ void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned in
 
 /* Colorscheme abstraction */
 void drw_clr_create(Drw *drw, Clr *dest, const char *clrname);
-Clr *drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount);
+Clr *drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount);
 
 /* Cursor abstraction */
 Cur *drw_cur_create(Drw *drw, int shape);
diff --git a/dwm.c b/dwm.c
index 1a94ca6..51c4ea9 100644
--- a/dwm.c
+++ b/dwm.c
@@ -36,6 +36,7 @@
 #include <X11/Xatom.h>
 #include <X11/Xlib.h>
 #include <X11/Xproto.h>
+#include <X11/Xresource.h>
 #include <X11/Xutil.h>
 #ifdef XINERAMA
 #include <X11/extensions/Xinerama.h>
@@ -58,6 +59,21 @@
 #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
 #define TAGMASK                 ((1 << LENGTH(tags)) - 1)
 #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
+#define XRDB_LOAD_COLOR(R,V)    if (XrmGetResource(xrdb, R, NULL, &type, &value) == True) { \
+                                  if (value.addr != NULL && strnlen(value.addr, 8) == 7 && value.addr[0] == '#') { \
+                                    int i = 1; \
+                                    for (; i <= 6; i++) { \
+                                      if (value.addr[i] < 48) break; \
+                                      if (value.addr[i] > 57 && value.addr[i] < 65) break; \
+                                      if (value.addr[i] > 70 && value.addr[i] < 97) break; \
+                                      if (value.addr[i] > 102) break; \
+                                    } \
+                                    if (i == 7) { \
+                                      strncpy(V, value.addr, 7); \
+                                      V[7] = '\0'; \
+                                    } \
+                                  } \
+                                }
 
 /* enums */
 enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
@@ -186,6 +202,7 @@ static void grabkeys(void);
 static void incnmaster(const Arg *arg);
 static void keypress(XEvent *e);
 static void killclient(const Arg *arg);
+static void loadxrdb(void);
 static void manage(Window w, XWindowAttributes *wa);
 static void mappingnotify(XEvent *e);
 static void maprequest(XEvent *e);
@@ -251,6 +268,7 @@ static Monitor *wintomon(Window w);
 static int xerror(Display *dpy, XErrorEvent *ee);
 static int xerrordummy(Display *dpy, XErrorEvent *ee);
 static int xerrorstart(Display *dpy, XErrorEvent *ee);
+static void xrdb(const Arg *arg);
 static void zoom(const Arg *arg);
 
 /* variables */
@@ -1187,6 +1205,37 @@ killclient(const Arg *arg)
 	}
 }
 
+void
+loadxrdb()
+{
+  Display *display;
+  char * resm;
+  XrmDatabase xrdb;
+  char *type;
+  XrmValue value;
+
+  display = XOpenDisplay(NULL);
+
+  if (display != NULL) {
+    resm = XResourceManagerString(display);
+
+    if (resm != NULL) {
+      xrdb = XrmGetStringDatabase(resm);
+
+      if (xrdb != NULL) {
+        XRDB_LOAD_COLOR("dwm.normbordercolor", normbordercolor);
+        XRDB_LOAD_COLOR("dwm.normbgcolor", normbgcolor);
+        XRDB_LOAD_COLOR("dwm.normfgcolor", normfgcolor);
+        XRDB_LOAD_COLOR("dwm.selbordercolor", selbordercolor);
+        XRDB_LOAD_COLOR("dwm.selbgcolor", selbgcolor);
+        XRDB_LOAD_COLOR("dwm.selfgcolor", selfgcolor);
+      }
+    }
+  }
+
+  XCloseDisplay(display);
+}
+
 void
 manage(Window w, XWindowAttributes *wa)
 {
@@ -2491,6 +2540,17 @@ xerrorstart(Display *dpy, XErrorEvent *ee)
 	return -1;
 }
 
+void
+xrdb(const Arg *arg)
+{
+  loadxrdb();
+  int i;
+  for (i = 0; i < LENGTH(colors); i++)
+                scheme[i] = drw_scm_create(drw, colors[i], 3);
+  focus(NULL);
+  arrange(NULL);
+}
+
 void
 zoom(const Arg *arg)
 {
@@ -2515,6 +2575,8 @@ main(int argc, char *argv[])
 	if (!(dpy = XOpenDisplay(NULL)))
 		die("dwm: cannot open display");
 	checkotherwm();
+        XrmInitialize();
+        loadxrdb();
 	setup();
 #ifdef __OpenBSD__
 	if (pledge("stdio rpath proc exec", NULL) == -1)
-- 
2.39.0


From 2f0704eb1acf518ad0cb3b5211204fab121bb9f8 Mon Sep 17 00:00:00 2001
From: UzairQamarxyz <uzairq@xgrid.co>
Date: Tue, 27 Dec 2022 22:45:06 +0500
Subject: [PATCH 11/13] Hotkeys n stuff

---
 config.def.h | 151 ++++++++++++++++++++++++++++++++-------------------
 util.o       | Bin 0 -> 2216 bytes
 2 files changed, 95 insertions(+), 56 deletions(-)
 create mode 100644 util.o

diff --git a/config.def.h b/config.def.h
index f2bb3cc..89cf77e 100644
--- a/config.def.h
+++ b/config.def.h
@@ -6,8 +6,8 @@ static const unsigned int gappx     = 5;        /* gaps between windows */
 static const unsigned int snap      = 32;       /* snap pixel */
 static const int showbar            = 1;        /* 0 means no bar */
 static const int topbar             = 1;        /* 0 means bottom bar */
-static const char *fonts[]          = { "monospace:size=10" };
-static const char dmenufont[]       = "monospace:size=10";
+static const char *fonts[]          = { "IBM Plex Mono:size=14" };
+static const char dmenufont[]       = "IBM Plex Mono:size=14";
 static char normbgcolor[]           = "#222222";
 static char normbordercolor[]       = "#444444";
 static char normfgcolor[]           = "#bbbbbb";
@@ -21,7 +21,7 @@ static char *colors[][3] = {
 };
 
 /* tagging */
-static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+static const char *tags[] = {"", "", "", "", "", "", ""};
 
 static const Rule rules[] = {
 	/* xprop(1):
@@ -59,65 +59,104 @@ static const Layout layouts[] = {
 
 /* commands */
 static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbordercolor, "-sf", selfgcolor, NULL };
-static const char *termcmd[]  = { "st", NULL };
+
+/* static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbordercolor, "-sf", selfgcolor, NULL }; */
+
+static const char *dmenucmd[] = {"dmenu_run", "-m", dmenumon, NULL};
+static const char *termcmd[]  = { "alacritty", NULL };
+static const char *emacs[]  = { "emacsclient", "-c", "-a", "'emacs'", NULL };
+static const char *browser[]  = { "alacritty", "-e", "$BROWSER", NULL };
+static const char *ranger[] = {"alacritty", "-e", "ranger", NULL};
+static const char *cmus[] = {"alacritty", "-e", "cmus", NULL};
+static const char *nmtui[]  = { "alacritty", "-e", "nmtui", NULL };
+static const char *dmenumount[]  = { "dmenumount", NULL };
+static const char *dmenuumount[]  = { "dmenumount", NULL };
+static const char *displayselect[]  = { "displayselect", NULL };
+static const char *sysact[]  = { "sysact", NULL };
+static const char *lockscreen[]  = { "betterlockscreen", "--lock", NULL };
+static const char *screenshot[]  = { "flameshot", "gui", NULL };
+static const char *brightnessup[]  = { "brightnessctl", "set", "10%+", NULL };
+static const char *brightnessdown[]  = { "brightnessctl", "set", "10%-", NULL };
+
+#include <X11/XF86keysym.h>
 
 static const Key keys[] = {
-	/* modifier                     key        function        argument */
-	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
-	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
-	{ MODKEY,                       XK_b,      togglebar,      {0} },
-	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
-	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
-	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
-	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
-	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
-	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
-	{ MODKEY,                       XK_Return, zoom,           {0} },
-	{ MODKEY,                       XK_Tab,    view,           {0} },
-	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
-	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
-	{ MODKEY,                       XK_f,      setlayout,      {.v = &layouts[1]} },
-	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
-	{ MODKEY,                       XK_space,  setlayout,      {0} },
-	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
-	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
-	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
-	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
-	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
-	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
-	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
-	{ MODKEY,                       XK_F5,     xrdb,           {.v = NULL } },
-	{ MODKEY,                       XK_Right,  viewnext,       {0} },
-	{ MODKEY,                       XK_Left,   viewprev,       {0} },
-	{ MODKEY|ShiftMask,             XK_Right,  tagtonext,      {0} },
-	{ MODKEY|ShiftMask,             XK_Left,   tagtoprev,      {0} },
-	TAGKEYS(                        XK_1,                      0)
-	TAGKEYS(                        XK_2,                      1)
-	TAGKEYS(                        XK_3,                      2)
-	TAGKEYS(                        XK_4,                      3)
-	TAGKEYS(                        XK_5,                      4)
-	TAGKEYS(                        XK_6,                      5)
-	TAGKEYS(                        XK_7,                      6)
-	TAGKEYS(                        XK_8,                      7)
-	TAGKEYS(                        XK_9,                      8)
-	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
-	{ MODKEY|ControlMask|ShiftMask, XK_q,      quit,           {1} }, 
+	/* modifier                     key                       function        argument */
+	{ MODKEY,                       XK_d,                     spawn,          {.v = dmenucmd } },
+	{ MODKEY,                       XK_Return,                spawn,          {.v = termcmd } },
+        { MODKEY,                       XK_e,                     spawn,          {.v = ranger} },
+        { MODKEY,                       XK_c,                     spawn,          {.v = cmus} },
+        { MODKEY,                       XK_F9,                    spawn,          {.v = dmenumount} },
+        { MODKEY,                       XK_F10,                   spawn,          {.v = dmenuumount} },
+        { MODKEY,                       XK_F7,                    spawn,          {.v = displayselect} },
+        { MODKEY,                       XK_BackSpace,             spawn,          {.v = sysact} },
+        { MODKEY,                       XK_w,                     spawn,          {.v = browser}},
+        { MODKEY|ShiftMask,             XK_w,                     spawn,          {.v = nmtui}},
+        { MODKEY,                       XK_x,                     spawn,          {.v = lockscreen}},
+        { 0,                            XF86XK_Calculator,        spawn,          {.v = emacs} },
+        { 0,                            XK_Print,                 spawn,          {.v = screenshot} },
+        { MODKEY,                       XK_p,                     spawn,          SHCMD("cmus-remote --pause && pkill -RTMIN+20 dwmblocks")},
+        { MODKEY,                       XK_bracketleft,           spawn,          SHCMD("cmus-remote --prev && pkill -RTMIN+20 dwmblocks")},
+        { MODKEY|ShiftMask,             XK_bracketleft,           spawn,          SHCMD("cmus-remote --seek -10 && pkill -RTMIN+20 dwmblocks")},
+        { MODKEY,                       XK_bracketright,          spawn,          SHCMD("cmus-remote --next && pkill -RTMIN+20 dwmblocks")},
+        { MODKEY|ShiftMask,             XK_bracketright,          spawn,          SHCMD("cmus-remote --seek +10")},
+        { 0,                            XF86XK_AudioMute,         spawn,          SHCMD("amixer set Master toggle && pkill -RTMIN+10 dwmblocks")},
+        { 0,                            XF86XK_AudioRaiseVolume,  spawn,          SHCMD("amixer set Master 5%+ && pkill -RTMIN+10 dwmblocks")},
+        { 0,                            XF86XK_AudioLowerVolume,  spawn,          SHCMD("amixer set Master 5%- && pkill -RTMIN+10 dwmblocks")},
+        { 0,                            XF86XK_MonBrightnessUp,   spawn,          {.v = brightnessup} },
+        { 0,                            XF86XK_MonBrightnessDown, spawn,          {.v = brightnessdown} },
+
+	{ MODKEY,                       XK_b,                     togglebar,      {0} },
+	{ MODKEY,                       XK_j,                     focusstack,     {.i = +1 } },
+	{ MODKEY,                       XK_k,                     focusstack,     {.i = -1 } },
+	{ MODKEY,                       XK_i,                     incnmaster,     {.i = +1 } },
+	{ MODKEY|ShiftMask,             XK_i,                     incnmaster,     {.i = -1 } },
+	{ MODKEY,                       XK_h,                     setmfact,       {.f = -0.05} },
+	{ MODKEY,                       XK_l,                     setmfact,       {.f = +0.05} },
+	{ MODKEY|ShiftMask,             XK_Return,                zoom,           {0} },
+	{ MODKEY,                       XK_Tab,                   view,           {0} },
+	{ MODKEY|ShiftMask,             XK_q,                     killclient,     {0} },
+	{ MODKEY,                       XK_t,                     setlayout,      {.v = &layouts[0]} },
+	{ MODKEY,                       XK_f,                     setlayout,      {.v = &layouts[1]} },
+	{ MODKEY,                       XK_m,                     setlayout,      {.v = &layouts[2]} },
+	{ MODKEY,                       XK_space,                 setlayout,      {0} },
+	{ MODKEY|ShiftMask,             XK_space,                 togglefloating, {0} },
+	{ MODKEY,                       XK_0,                     view,           {.ui = ~0 } },
+	{ MODKEY|ShiftMask,             XK_0,                     tag,            {.ui = ~0 } },
+	{ MODKEY,                       XK_comma,                 focusmon,       {.i = -1 } },
+	{ MODKEY,                       XK_period,                focusmon,       {.i = +1 } },
+	{ MODKEY|ShiftMask,             XK_comma,                 tagmon,         {.i = -1 } },
+	{ MODKEY|ShiftMask,             XK_period,                tagmon,         {.i = +1 } },
+	{ MODKEY,                       XK_F5,                    xrdb,           {.v = NULL } },
+	{ MODKEY,                       XK_Right,                 viewnext,       {0} },
+	{ MODKEY,                       XK_Left,                  viewprev,       {0} },
+	{ MODKEY|ShiftMask,             XK_Right,                 tagtonext,      {0} },
+	{ MODKEY|ShiftMask,             XK_Left,                  tagtoprev,      {0} },
+	TAGKEYS(                        XK_1,                                     0)
+	TAGKEYS(                        XK_2,                                     1)
+	TAGKEYS(                        XK_3,                                     2)
+	TAGKEYS(                        XK_4,                                     3)
+	TAGKEYS(                        XK_5,                                     4)
+	TAGKEYS(                        XK_6,                                     5)
+	TAGKEYS(                        XK_7,                                     6)
+     /* TAGKEYS(                        XK_8,                                     7)
+	TAGKEYS(                        XK_9,                                     8) */
+	{ MODKEY|ControlMask|ShiftMask, XK_q,                     quit,           {1} }, 
 };
 
 /* button definitions */
 /* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle, ClkClientWin, or ClkRootWin */
 static const Button buttons[] = {
-	/* click                event mask      button          function        argument */
-	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
-	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
-	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
-	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
-	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
-	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
-	{ ClkTagBar,            0,              Button1,        view,           {0} },
-	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
-	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
-	{ ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
+	/* click                  event mask      button          function        argument */
+	{ ClkLtSymbol,            0,              Button1,        setlayout,      {0} },
+	{ ClkLtSymbol,            0,              Button3,        setlayout,      {.v = &layouts[2]} },
+	{ ClkStatusText,          0,              Button2,        spawn,          {.v = termcmd } },
+	{ ClkClientWin,           MODKEY,         Button1,        movemouse,      {0} },
+	{ ClkClientWin,           MODKEY,         Button2,        togglefloating, {0} },
+	{ ClkClientWin|ShiftMask, MODKEY,         Button1,        resizemouse,    {0} },
+	{ ClkTagBar,              0,              Button1,        view,           {0} },
+	{ ClkTagBar,              0,              Button3,        toggleview,     {0} },
+	{ ClkTagBar,              MODKEY,         Button1,        tag,            {0} },
+	{ ClkTagBar,              MODKEY,         Button3,        toggletag,      {0} },
 };
 
diff --git a/util.o b/util.o
new file mode 100644
index 0000000000000000000000000000000000000000..6ab501f771232ee94bd1d5e3f8348ea759683421
GIT binary patch
literal 2216
zcmbtVJ!n%=6h5!5Hr6zWZHG!7B0MF5`e+J5NmZha_9;PXRn#t;CNDOaKVNPnRl$mN
z2qn<L(V>Hbf`g!=(4d2>qmy+M>QDy<sSwY(@80(Ecv<wo<vaH~-#Pc>{=7Uon>yE}
zX&_C5Q?NUeEI?$>uAks;0s_zvm(9ku`S`~-q|64>C(OnbJz+Ldx|wPu^_diU*Oyx?
z9*idSTft~buLPsd^d*!BqtEqKjxY2zj<5AM9N+0Jj_>u)h*@)`=STz{6AMOSEpz20
zPH^_sY%c3tA~0+=ujnDOnbgNVCH0UGX~dy15e|Px2bLzmTscl28#Nmn)Ub~S%oX&O
z9(K3mwZZi;#yJ~nbJ*-#?~~Lz?G0xyIf+kOHNV;99dTmrV<ufFlrwRF>8YuBI5K_l
zYBU@hH^vR>1$uCVanN>R2)aOP5hwRt6Z3t@kqtQj+WlG3>LG2!-|JgN@i6j-MC>==
z=|Jd7*M-2Ah)sytK@qza@Cn8nX#F1e+4hQd?{v2tb*d?sLWKGe2NXT;4Y>n2LPDbg
z{SGhwa0fopfj2tvblP6^@qBonvOm60$W3<8LyhGNMh1-3)EH#*7F1c*vTeARtJwJx
z%i-KESS83+YAgd443%xL>Ujp1b0M%US<L}FcjpfLX*>2x@N^gU;*k7X!MpVz6n(Fv
z|Dy18MzYR^!qeT7{HDUI`d<o9w_obF72dD#y>x-lsLyU3QtuZ${Vp1k52H^;dK%JB
z2uJere88wK7Fl{8k=YI|NYAzkX@gmH21Yi`(qPP2t6<n=nvgtZ#K6dui$$x1l2Vyj
z20p!GRhG`&5%b%nno+UKcy4SFQ>mb}a5HD8i<a!{|1gZ{v=wx=swKo^K<tx@xu!6J
z0ouQW6bP))W~2E;!hZD0b>64*ouK$p!3#N2+-BVi3EoYQB2P8{H9v;ARC64MYI1$q
zuZ+p{B_=RHKL3bH5#pQ>3@RMCGEd@pg;S+PDNsod?G5DUovC+~QYs?f-Ix3K+(j)(
z-T7-Ge};-F=FTr*%<KH?M54*{>HO(^%Y6F2l6kF7JpEsgO$eknO(os=RMUO-NI^u9
aXK13BD7VAV_uni3rRe{`j?!`5`F{Z;iVAT6

literal 0
HcmV?d00001

-- 
2.39.0


From ec3630b0e9b1fb975779a3660e1e1c671cb90453 Mon Sep 17 00:00:00 2001
From: UzairQamarxyz <uzairq@xgrid.co>
Date: Tue, 27 Dec 2022 23:46:08 +0500
Subject: [PATCH 12/13] Font change + status2d xrdb patch

---
 config.def.h | 46 ++++++++++++++++++++++++++++++++++++++++------
 dwm.c        | 22 ++++++++++++++++++++++
 2 files changed, 62 insertions(+), 6 deletions(-)

diff --git a/config.def.h b/config.def.h
index 89cf77e..d39f43d 100644
--- a/config.def.h
+++ b/config.def.h
@@ -1,19 +1,53 @@
 /* See LICENSE file for copyright and license details. */
 
 /* appearance */
-static const unsigned int borderpx  = 1;        /* border pixel of windows */
-static const unsigned int gappx     = 5;        /* gaps between windows */
+static const unsigned int borderpx  = 0;        /* border pixel of windows */
+static const unsigned int gappx     = 8;        /* gaps between windows */
 static const unsigned int snap      = 32;       /* snap pixel */
 static const int showbar            = 1;        /* 0 means no bar */
 static const int topbar             = 1;        /* 0 means bottom bar */
-static const char *fonts[]          = { "IBM Plex Mono:size=14" };
-static const char dmenufont[]       = "IBM Plex Mono:size=14";
+static const char *fonts[]          = { "Iosevka Custom:size=14" };
+static const char dmenufont[]       = "Iosevka Custom:size=14";
 static char normbgcolor[]           = "#222222";
 static char normbordercolor[]       = "#444444";
 static char normfgcolor[]           = "#bbbbbb";
 static char selfgcolor[]            = "#eeeeee";
 static char selbordercolor[]        = "#005577";
 static char selbgcolor[]            = "#005577";
+static char termcol0[] = "#000000"; /* black   */
+static char termcol1[] = "#ff0000"; /* red     */
+static char termcol2[] = "#33ff00"; /* green   */
+static char termcol3[] = "#ff0099"; /* yellow  */
+static char termcol4[] = "#0066ff"; /* blue    */
+static char termcol5[] = "#cc00ff"; /* magenta */
+static char termcol6[] = "#00ffff"; /* cyan    */
+static char termcol7[] = "#d0d0d0"; /* white   */
+static char termcol8[]  = "#808080"; /* black   */
+static char termcol9[]  = "#ff0000"; /* red     */
+static char termcol10[] = "#33ff00"; /* green   */
+static char termcol11[] = "#ff0099"; /* yellow  */
+static char termcol12[] = "#0066ff"; /* blue    */
+static char termcol13[] = "#cc00ff"; /* magenta */
+static char termcol14[] = "#00ffff"; /* cyan    */
+static char termcol15[] = "#ffffff"; /* white   */
+static char *termcolor[] = {
+  termcol0,
+  termcol1,
+  termcol2,
+  termcol3,
+  termcol4,
+  termcol5,
+  termcol6,
+  termcol7,
+  termcol8,
+  termcol9,
+  termcol10,
+  termcol11,
+  termcol12,
+  termcol13,
+  termcol14,
+  termcol15,
+};
 static char *colors[][3] = {
        /*               fg           bg           border   */
        [SchemeNorm] = { normfgcolor, normbgcolor, normbordercolor },
@@ -47,7 +81,7 @@ static const Layout layouts[] = {
 };
 
 /* key definitions */
-#define MODKEY Mod1Mask
+#define MODKEY Mod4Mask
 #define TAGKEYS(KEY,TAG) \
 	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
@@ -65,7 +99,7 @@ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn()
 static const char *dmenucmd[] = {"dmenu_run", "-m", dmenumon, NULL};
 static const char *termcmd[]  = { "alacritty", NULL };
 static const char *emacs[]  = { "emacsclient", "-c", "-a", "'emacs'", NULL };
-static const char *browser[]  = { "alacritty", "-e", "$BROWSER", NULL };
+static const char *browser[]  = { "firefox", NULL };
 static const char *ranger[] = {"alacritty", "-e", "ranger", NULL};
 static const char *cmus[] = {"alacritty", "-e", "cmus", NULL};
 static const char *nmtui[]  = { "alacritty", "-e", "nmtui", NULL };
diff --git a/dwm.c b/dwm.c
index 51c4ea9..860e274 100644
--- a/dwm.c
+++ b/dwm.c
@@ -846,6 +846,12 @@ drawstatusbar(Monitor *m, int bh, char* stext) {
 					buf[7] = '\0';
 					drw_clr_create(drw, &drw->scheme[ColBg], buf);
 					i += 7;
+				} else if (text[i] == 'C') {
+					int c = atoi(text + ++i);
+					drw_clr_create(drw, &drw->scheme[ColFg], termcolor[c]);
+				} else if (text[i] == 'B') {
+					int c = atoi(text + ++i);
+					drw_clr_create(drw, &drw->scheme[ColBg], termcolor[c]);
 				} else if (text[i] == 'd') {
 					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
 					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
@@ -1229,6 +1235,22 @@ loadxrdb()
         XRDB_LOAD_COLOR("dwm.selbordercolor", selbordercolor);
         XRDB_LOAD_COLOR("dwm.selbgcolor", selbgcolor);
         XRDB_LOAD_COLOR("dwm.selfgcolor", selfgcolor);
+        XRDB_LOAD_COLOR("color0",  termcol0);
+        XRDB_LOAD_COLOR("color1",  termcol1);
+        XRDB_LOAD_COLOR("color2",  termcol2);
+        XRDB_LOAD_COLOR("color3",  termcol3);
+        XRDB_LOAD_COLOR("color4",  termcol4);
+        XRDB_LOAD_COLOR("color5",  termcol5);
+        XRDB_LOAD_COLOR("color6",  termcol6);
+        XRDB_LOAD_COLOR("color7",  termcol7);
+        XRDB_LOAD_COLOR("color8",  termcol8);
+        XRDB_LOAD_COLOR("color9",  termcol9);
+        XRDB_LOAD_COLOR("color10", termcol10);
+        XRDB_LOAD_COLOR("color11", termcol11);
+        XRDB_LOAD_COLOR("color12", termcol12);
+        XRDB_LOAD_COLOR("color13", termcol13);
+        XRDB_LOAD_COLOR("color14", termcol14);
+        XRDB_LOAD_COLOR("color15", termcol15);
       }
     }
   }
-- 
2.39.0


From 666ab5eb91fda73cfe3452cbafebf62ce0dfc191 Mon Sep 17 00:00:00 2001
From: UzairQamarxyz <uzairq@xgrid.co>
Date: Wed, 28 Dec 2022 14:04:30 +0500
Subject: [PATCH 13/13] Adding patches

---
 .gitignore                                    |   1 -
 patches/dwm-adjacenttag-6.2.diff              | 126 ++++
 patches/dwm-attachaside-6.3.diff              |  92 +++
 patches/dwm-autostart-20210120-cb3f58a.diff   | 179 ++++++
 patches/dwm-barpadding-20211020-a786211.diff  | 118 ++++
 patches/dwm-center-6.2.diff                   |  90 +++
 patches/dwm-fixborders-6.2.diff               |  27 +
 patches/dwm-fullgaps-20200508-7b77734.diff    | 138 +++++
 patches/dwm-integrated-status-text-6.3.diff   | 539 ++++++++++++++++++
 patches/dwm-notitle-20210715-138b405.diff     |  81 +++
 patches/dwm-pertag-20200914-61bb8b2.diff      | 177 ++++++
 patches/dwm-restartsig-20180523-6.2.diff      | 139 +++++
 patches/dwm-status2d-20200508-60bb3df.diff    | 180 ++++++
 patches/dwm-status2d-6.3.diff                 | 166 ++++++
 patches/dwm-status2d-xrdb-6.2.diff            | 100 ++++
 .../dwm-statuscolors-20220322-bece862.diff    |  83 +++
 patches/dwm-swallow-6.3.diff                  | 412 +++++++++++++
 patches/dwm-xrdb-6.2.diff                     | 188 ++++++
 18 files changed, 2835 insertions(+), 1 deletion(-)
 create mode 100644 patches/dwm-adjacenttag-6.2.diff
 create mode 100644 patches/dwm-attachaside-6.3.diff
 create mode 100644 patches/dwm-autostart-20210120-cb3f58a.diff
 create mode 100644 patches/dwm-barpadding-20211020-a786211.diff
 create mode 100644 patches/dwm-center-6.2.diff
 create mode 100644 patches/dwm-fixborders-6.2.diff
 create mode 100644 patches/dwm-fullgaps-20200508-7b77734.diff
 create mode 100644 patches/dwm-integrated-status-text-6.3.diff
 create mode 100644 patches/dwm-notitle-20210715-138b405.diff
 create mode 100644 patches/dwm-pertag-20200914-61bb8b2.diff
 create mode 100644 patches/dwm-restartsig-20180523-6.2.diff
 create mode 100644 patches/dwm-status2d-20200508-60bb3df.diff
 create mode 100644 patches/dwm-status2d-6.3.diff
 create mode 100644 patches/dwm-status2d-xrdb-6.2.diff
 create mode 100644 patches/dwm-statuscolors-20220322-bece862.diff
 create mode 100644 patches/dwm-swallow-6.3.diff
 create mode 100644 patches/dwm-xrdb-6.2.diff

diff --git a/.gitignore b/.gitignore
index 47c20db..544593c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,4 +3,3 @@ dwm.o
 drw.o
 *.rej
 *.orig
-patches/
diff --git a/patches/dwm-adjacenttag-6.2.diff b/patches/dwm-adjacenttag-6.2.diff
new file mode 100644
index 0000000..6121f65
--- /dev/null
+++ b/patches/dwm-adjacenttag-6.2.diff
@@ -0,0 +1,126 @@
+diff -up a/config.def.h b/config.def.h
+--- a/config.def.h	2021-10-02 13:57:18.011307099 +0100
++++ b/config.def.h	2021-10-02 13:58:07.812080253 +0100
+@@ -84,6 +84,10 @@ static Key keys[] = {
+ 	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
+ 	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
+ 	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
++	{ MODKEY,                       XK_Right,  viewnext,       {0} },
++	{ MODKEY,                       XK_Left,   viewprev,       {0} },
++	{ MODKEY|ShiftMask,             XK_Right,  tagtonext,      {0} },
++	{ MODKEY|ShiftMask,             XK_Left,   tagtoprev,      {0} },
+ 	TAGKEYS(                        XK_1,                      0)
+ 	TAGKEYS(                        XK_2,                      1)
+ 	TAGKEYS(                        XK_3,                      2)
+diff -up a/dwm.c b/dwm.c
+--- a/dwm.c	2021-10-02 13:57:18.011307099 +0100
++++ b/dwm.c	2021-10-02 14:21:17.063622953 +0100
+@@ -183,8 +183,10 @@ static void maprequest(XEvent *e);
+ static void monocle(Monitor *m);
+ static void motionnotify(XEvent *e);
+ static void movemouse(const Arg *arg);
++static unsigned int nexttag(void);
+ static Client *nexttiled(Client *c);
+ static void pop(Client *);
++static unsigned int prevtag(void);
+ static void propertynotify(XEvent *e);
+ static void quit(const Arg *arg);
+ static Monitor *recttomon(int x, int y, int w, int h);
+@@ -208,6 +210,8 @@ static void sigchld(int unused);
+ static void spawn(const Arg *arg);
+ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
++static void tagtonext(const Arg *arg);
++static void tagtoprev(const Arg *arg);
+ static void tile(Monitor *);
+ static void togglebar(const Arg *arg);
+ static void togglefloating(const Arg *arg);
+@@ -227,6 +231,8 @@ static void updatetitle(Client *c);
+ static void updatewindowtype(Client *c);
+ static void updatewmhints(Client *c);
+ static void view(const Arg *arg);
++static void viewnext(const Arg *arg);
++static void viewprev(const Arg *arg);
+ static Client *wintoclient(Window w);
+ static Monitor *wintomon(Window w);
+ static int xerror(Display *dpy, XErrorEvent *ee);
+@@ -1192,6 +1198,13 @@ movemouse(const Arg *arg)
+ 	}
+ }
+ 
++unsigned int
++nexttag(void)
++{
++	unsigned int seltag = selmon->tagset[selmon->seltags];
++	return seltag == (1 << (LENGTH(tags) - 1)) ? 1 : seltag << 1;
++}
++
+ Client *
+ nexttiled(Client *c)
+ {
+@@ -1208,6 +1221,13 @@ pop(Client *c)
+ 	arrange(c->mon);
+ }
+ 
++unsigned int
++prevtag(void)
++{
++	unsigned int seltag = selmon->tagset[selmon->seltags];
++	return seltag == 1 ? (1 << (LENGTH(tags) - 1)) : seltag >> 1;
++}
++
+ void
+ propertynotify(XEvent *e)
+ {
+@@ -1671,6 +1691,32 @@ tagmon(const Arg *arg)
+ }
+ 
+ void
++tagtonext(const Arg *arg)
++{
++	unsigned int tmp;
++
++	if (selmon->sel == NULL)
++		return;
++
++	tmp = nexttag();
++	tag(&(const Arg){.ui = tmp });
++	view(&(const Arg){.ui = tmp });
++}
++
++void
++tagtoprev(const Arg *arg)
++{
++	unsigned int tmp;
++
++	if (selmon->sel == NULL)
++		return;
++
++	tmp = prevtag();
++	tag(&(const Arg){.ui = tmp });
++	view(&(const Arg){.ui = tmp });
++}
++
++void
+ tile(Monitor *m)
+ {
+ 	unsigned int i, n, h, mw, my, ty;
+@@ -2044,6 +2090,18 @@ view(const Arg *arg)
+ 	arrange(selmon);
+ }
+ 
++void
++viewnext(const Arg *arg)
++{
++	view(&(const Arg){.ui = nexttag()});
++}
++
++void
++viewprev(const Arg *arg)
++{
++	view(&(const Arg){.ui = prevtag()});
++}
++ 
+ Client *
+ wintoclient(Window w)
+ {
diff --git a/patches/dwm-attachaside-6.3.diff b/patches/dwm-attachaside-6.3.diff
new file mode 100644
index 0000000..2d263c4
--- /dev/null
+++ b/patches/dwm-attachaside-6.3.diff
@@ -0,0 +1,92 @@
+diff --git a/dwm.c b/dwm.c
+index 0362114..be7e7a6 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -49,7 +49,8 @@
+ #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
+ #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
+                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
+-#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
++#define ISVISIBLEONTAG(C, T)    ((C->tags & T))
++#define ISVISIBLE(C)            ISVISIBLEONTAG(C, C->mon->tagset[C->mon->seltags])
+ #define LENGTH(X)               (sizeof X / sizeof X[0])
+ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+@@ -147,6 +148,7 @@ static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interac
+ static void arrange(Monitor *m);
+ static void arrangemon(Monitor *m);
+ static void attach(Client *c);
++static void attachaside(Client *c);
+ static void attachstack(Client *c);
+ static void buttonpress(XEvent *e);
+ static void checkotherwm(void);
+@@ -184,6 +186,7 @@ static void maprequest(XEvent *e);
+ static void monocle(Monitor *m);
+ static void motionnotify(XEvent *e);
+ static void movemouse(const Arg *arg);
++static Client *nexttagged(Client *c);
+ static Client *nexttiled(Client *c);
+ static void pop(Client *);
+ static void propertynotify(XEvent *e);
+@@ -406,6 +409,17 @@ attach(Client *c)
+ }
+ 
+ void
++attachaside(Client *c) {
++	Client *at = nexttagged(c);
++	if(!at) {
++		attach(c);
++		return;
++	}
++	c->next = at->next;
++	at->next = c;
++}
++
++void
+ attachstack(Client *c)
+ {
+ 	c->snext = c->mon->stack;
+@@ -1076,7 +1090,7 @@ manage(Window w, XWindowAttributes *wa)
+ 		c->isfloating = c->oldstate = trans != None || c->isfixed;
+ 	if (c->isfloating)
+ 		XRaiseWindow(dpy, c->win);
+-	attach(c);
++	attachaside(c);
+ 	attachstack(c);
+ 	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
+ 		(unsigned char *) &(c->win), 1);
+@@ -1210,6 +1224,16 @@ movemouse(const Arg *arg)
+ }
+ 
+ Client *
++nexttagged(Client *c) {
++	Client *walked = c->mon->clients;
++	for(;
++		walked && (walked->isfloating || !ISVISIBLEONTAG(walked, c->tags));
++		walked = walked->next
++	);
++	return walked;
++}
++
++Client *
+ nexttiled(Client *c)
+ {
+ 	for (; c && (c->isfloating || !ISVISIBLE(c)); c = c->next);
+@@ -1434,7 +1458,7 @@ sendmon(Client *c, Monitor *m)
+ 	detachstack(c);
+ 	c->mon = m;
+ 	c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
+-	attach(c);
++	attachaside(c);
+ 	attachstack(c);
+ 	focus(NULL);
+ 	arrange(NULL);
+@@ -1891,7 +1915,7 @@ updategeom(void)
+ 					m->clients = c->next;
+ 					detachstack(c);
+ 					c->mon = mons;
+-					attach(c);
++					attachaside(c);
+ 					attachstack(c);
+ 				}
+ 				if (m == selmon)
diff --git a/patches/dwm-autostart-20210120-cb3f58a.diff b/patches/dwm-autostart-20210120-cb3f58a.diff
new file mode 100644
index 0000000..efee676
--- /dev/null
+++ b/patches/dwm-autostart-20210120-cb3f58a.diff
@@ -0,0 +1,179 @@
+From 37e970479dc5d40e57fc0cbfeaa5e39941483237 Mon Sep 17 00:00:00 2001
+From: Gan Ainm <gan.ainm.riomhphost@gmail.com>
+Date: Wed, 10 Jun 2020 10:59:02 +0000
+Subject: [PATCH] dwm-xdgautostart-6.2.diff
+
+===================================================================
+---
+ dwm.1 | 23 +++++++++++++++++
+ dwm.c | 82 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ 2 files changed, 105 insertions(+)
+
+diff --git a/dwm.1 b/dwm.1
+index 13b3729..9533aa6 100644
+--- a/dwm.1
++++ b/dwm.1
+@@ -30,6 +30,14 @@ top left corner.  The tags which are applied to one or more windows are
+ indicated with an empty square in the top left corner.
+ .P
+ dwm draws a small border around windows to indicate the focus state.
++.P
++On start, dwm can start additional programs that may be specified in two special
++shell scripts (see the FILES section below), autostart_blocking.sh and
++autostart.sh.  The former is executed first and dwm will wait for its
++termination before starting.  The latter is executed in the background before
++dwm enters its handler loop.
++.P
++Either of these files may be omitted.
+ .SH OPTIONS
+ .TP
+ .B \-v
+@@ -152,6 +160,21 @@ Toggles focused window between floating and tiled state.
+ .TP
+ .B Mod1\-Button3
+ Resize focused window while dragging. Tiled windows will be toggled to the floating state.
++.SH FILES
++The files containing programs to be started along with dwm are searched for in
++the following directories:
++.IP "1. $XDG_DATA_HOME/dwm"
++.IP "2. $HOME/.local/share/dwm"
++.IP "3. $HOME/.dwm"
++.P
++The first existing directory is scanned for any of the autostart files below.
++.TP 15
++autostart.sh
++This file is started as a shell background process before dwm enters its handler
++loop.
++.TP 15
++autostart_blocking.sh
++This file is started before any autostart.sh; dwm waits for its termination.
+ .SH CUSTOMIZATION
+ dwm is customized by creating a custom config.h and (re)compiling the source
+ code. This keeps it fast, secure and simple.
+diff --git a/dwm.c b/dwm.c
+index 4465af1..2156b49 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -29,6 +29,7 @@
+ #include <string.h>
+ #include <unistd.h>
+ #include <sys/types.h>
++#include <sys/stat.h>
+ #include <sys/wait.h>
+ #include <X11/cursorfont.h>
+ #include <X11/keysym.h>
+@@ -193,6 +194,7 @@ static void resizeclient(Client *c, int x, int y, int w, int h);
+ static void resizemouse(const Arg *arg);
+ static void restack(Monitor *m);
+ static void run(void);
++static void runautostart(void);
+ static void scan(void);
+ static int sendevent(Client *c, Atom proto);
+ static void sendmon(Client *c, Monitor *m);
+@@ -235,7 +237,11 @@ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+ static void zoom(const Arg *arg);
+ 
+ /* variables */
++static const char autostartblocksh[] = "autostart_blocking.sh";
++static const char autostartsh[] = "autostart.sh";
+ static const char broken[] = "broken";
++static const char dwmdir[] = "dwm";
++static const char localshare[] = ".local/share";
+ static char stext[256];
+ static int screen;
+ static int sw, sh;           /* X display screen geometry width, height */
+@@ -1380,6 +1386,83 @@ run(void)
+ 			handler[ev.type](&ev); /* call handler */
+ }
+ 
++void
++runautostart(void)
++{
++	char *pathpfx;
++	char *path;
++	char *xdgdatahome;
++	char *home;
++	struct stat sb;
++
++	if ((home = getenv("HOME")) == NULL)
++		/* this is almost impossible */
++		return;
++
++	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
++	 * otherwise use ~/.local/share/dwm as autostart script directory
++	 */
++	xdgdatahome = getenv("XDG_DATA_HOME");
++	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
++		/* space for path segments, separators and nul */
++		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
++
++		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
++			free(pathpfx);
++			return;
++		}
++	} else {
++		/* space for path segments, separators and nul */
++		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
++		                     + strlen(dwmdir) + 3);
++
++		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
++			free(pathpfx);
++			return;
++		}
++	}
++
++	/* check if the autostart script directory exists */
++	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
++		/* the XDG conformant path does not exist or is no directory
++		 * so we try ~/.dwm instead
++		 */
++		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
++		if(pathpfx_new == NULL) {
++			free(pathpfx);
++			return;
++		}
++		pathpfx = pathpfx_new;
++
++		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
++			free(pathpfx);
++			return;
++		}
++	}
++
++	/* try the blocking script first */
++	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
++	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
++		free(path);
++		free(pathpfx);
++	}
++
++	if (access(path, X_OK) == 0)
++		system(path);
++
++	/* now the non-blocking script */
++	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
++		free(path);
++		free(pathpfx);
++	}
++
++	if (access(path, X_OK) == 0)
++		system(strcat(path, " &"));
++
++	free(pathpfx);
++	free(path);
++}
++
+ void
+ scan(void)
+ {
+@@ -2142,6 +2223,7 @@ main(int argc, char *argv[])
+ 		die("pledge");
+ #endif /* __OpenBSD__ */
+ 	scan();
++	runautostart();
+ 	run();
+ 	cleanup();
+ 	XCloseDisplay(dpy);
+-- 
+2.27.0
+
diff --git a/patches/dwm-barpadding-20211020-a786211.diff b/patches/dwm-barpadding-20211020-a786211.diff
new file mode 100644
index 0000000..7842181
--- /dev/null
+++ b/patches/dwm-barpadding-20211020-a786211.diff
@@ -0,0 +1,118 @@
+From a3cfb215f7f647d83d67e33df8f33a73e43bd65f Mon Sep 17 00:00:00 2001
+From: Bakkeby <bakkeby@gmail.com>
+Date: Wed, 20 Oct 2021 09:14:07 +0200
+Subject: [PATCH] barpadding: adds space between the statusbar and the edge of
+ the screen
+
+---
+ config.def.h |  2 ++
+ dwm.c        | 25 +++++++++++++++----------
+ 2 files changed, 17 insertions(+), 10 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index a2ac963..f0b739f 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -5,6 +5,8 @@ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+ static const unsigned int snap      = 32;       /* snap pixel */
+ static const int showbar            = 1;        /* 0 means no bar */
+ static const int topbar             = 1;        /* 0 means bottom bar */
++static const int vertpad            = 10;       /* vertical padding of bar */
++static const int sidepad            = 10;       /* horizontal padding of bar */
+ static const char *fonts[]          = { "monospace:size=10" };
+ static const char dmenufont[]       = "monospace:size=10";
+ static const char col_gray1[]       = "#222222";
+diff --git a/dwm.c b/dwm.c
+index 5e4d494..df6d0d7 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -242,6 +242,8 @@ static int screen;
+ static int sw, sh;           /* X display screen geometry width, height */
+ static int bh, blw = 0;      /* bar geometry */
+ static int lrpad;            /* sum of left and right padding for text */
++static int vp;               /* vertical padding for bar */
++static int sp;               /* side padding for bar */
+ static int (*xerrorxlib)(Display *, XErrorEvent *);
+ static unsigned int numlockmask = 0;
+ static void (*handler[LASTEvent]) (XEvent *) = {
+@@ -568,7 +570,7 @@ configurenotify(XEvent *e)
+ 				for (c = m->clients; c; c = c->next)
+ 					if (c->isfullscreen)
+ 						resizeclient(c, m->mx, m->my, m->mw, m->mh);
+-				XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
++				XMoveResizeWindow(dpy, m->barwin, m->wx + sp, m->by + vp, m->ww -  2 * sp, bh);
+ 			}
+ 			focus(NULL);
+ 			arrange(NULL);
+@@ -706,7 +708,7 @@ drawbar(Monitor *m)
+ 	if (m == selmon) { /* status is only drawn on selected monitor */
+ 		drw_setscheme(drw, scheme[SchemeNorm]);
+ 		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
+-		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
++		drw_text(drw, m->ww - tw - 2 * sp, 0, tw, bh, 0, stext, 0);
+ 	}
+ 
+ 	for (c = m->clients; c; c = c->next) {
+@@ -732,12 +734,12 @@ drawbar(Monitor *m)
+ 	if ((w = m->ww - tw - x) > bh) {
+ 		if (m->sel) {
+ 			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
+-			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
++			drw_text(drw, x, 0, w - 2 * sp, bh, lrpad / 2, m->sel->name, 0);
+ 			if (m->sel->isfloating)
+ 				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
+ 		} else {
+ 			drw_setscheme(drw, scheme[SchemeNorm]);
+-			drw_rect(drw, x, 0, w, bh, 1, 1);
++			drw_rect(drw, x, 0, w - 2 * sp, bh, 1, 1);
+ 		}
+ 	}
+ 	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
+@@ -1547,7 +1549,10 @@ setup(void)
+ 		die("no fonts could be loaded.");
+ 	lrpad = drw->fonts->h;
+ 	bh = drw->fonts->h + 2;
++	sp = sidepad;
++	vp = (topbar == 1) ? vertpad : - vertpad;
+ 	updategeom();
++
+ 	/* init atoms */
+ 	utf8string = XInternAtom(dpy, "UTF8_STRING", False);
+ 	wmatom[WMProtocols] = XInternAtom(dpy, "WM_PROTOCOLS", False);
+@@ -1704,7 +1709,7 @@ togglebar(const Arg *arg)
+ {
+ 	selmon->showbar = !selmon->showbar;
+ 	updatebarpos(selmon);
+-	XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
++	XMoveResizeWindow(dpy, selmon->barwin, selmon->wx + sp, selmon->by + vp, selmon->ww - 2 * sp, bh);
+ 	arrange(selmon);
+ }
+ 
+@@ -1814,7 +1819,7 @@ updatebars(void)
+ 	for (m = mons; m; m = m->next) {
+ 		if (m->barwin)
+ 			continue;
+-		m->barwin = XCreateWindow(dpy, root, m->wx, m->by, m->ww, bh, 0, DefaultDepth(dpy, screen),
++		m->barwin = XCreateWindow(dpy, root, m->wx + sp, m->by + vp, m->ww - 2 * sp, bh, 0, DefaultDepth(dpy, screen),
+ 				CopyFromParent, DefaultVisual(dpy, screen),
+ 				CWOverrideRedirect|CWBackPixmap|CWEventMask, &wa);
+ 		XDefineCursor(dpy, m->barwin, cursor[CurNormal]->cursor);
+@@ -1829,11 +1834,11 @@ updatebarpos(Monitor *m)
+ 	m->wy = m->my;
+ 	m->wh = m->mh;
+ 	if (m->showbar) {
+-		m->wh -= bh;
+-		m->by = m->topbar ? m->wy : m->wy + m->wh;
+-		m->wy = m->topbar ? m->wy + bh : m->wy;
++		m->wh = m->wh - vertpad - bh;
++		m->by = m->topbar ? m->wy : m->wy + m->wh + vertpad;
++		m->wy = m->topbar ? m->wy + bh + vp : m->wy;
+ 	} else
+-		m->by = -bh;
++		m->by = -bh - vp;
+ }
+ 
+ void
+-- 
+2.33.0
+
diff --git a/patches/dwm-center-6.2.diff b/patches/dwm-center-6.2.diff
new file mode 100644
index 0000000..0dfe156
--- /dev/null
+++ b/patches/dwm-center-6.2.diff
@@ -0,0 +1,90 @@
+From 69f91089d9248fa9695eb925956e255a215171b8 Mon Sep 17 00:00:00 2001
+From: bakkeby <bakkeby@gmail.com>
+Date: Tue, 7 Apr 2020 12:29:08 +0200
+Subject: [PATCH] Adding 6.2 center patch with multi-monitor fix and
+ auto-centering of floating popup windows
+---
+ config.def.h |  6 +++---
+ dwm.c        | 13 +++++++++++--
+ 2 files changed, 14 insertions(+), 5 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index 1c0b587..44b46e5 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -26,9 +26,9 @@ static const Rule rules[] = {
+ 	 *	WM_CLASS(STRING) = instance, class
+ 	 *	WM_NAME(STRING) = title
+ 	 */
+-	/* class      instance    title       tags mask     isfloating   monitor */
+-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
+-	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
++	/* class      instance    title       tags mask     iscentered   isfloating   monitor */
++	{ "Gimp",     NULL,       NULL,       0,            0,           1,           -1 },
++	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           0,           -1 },
+ };
+ 
+ /* layout(s) */
+diff --git a/dwm.c b/dwm.c
+index 4465af1..ab33757 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -92,7 +92,7 @@ struct Client {
+ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh;
+ 	int bw, oldbw;
+ 	unsigned int tags;
+-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
++	int isfixed, iscentered, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
+ 	Client *next;
+ 	Client *snext;
+ 	Monitor *mon;
+@@ -137,6 +137,7 @@ typedef struct {
+ 	const char *instance;
+ 	const char *title;
+ 	unsigned int tags;
++	int iscentered;
+ 	int isfloating;
+ 	int monitor;
+ } Rule;
+@@ -285,6 +286,7 @@ applyrules(Client *c)
+ 	XClassHint ch = { NULL, NULL };
+ 
+ 	/* rule matching */
++	c->iscentered = 0;
+ 	c->isfloating = 0;
+ 	c->tags = 0;
+ 	XGetClassHint(dpy, c->win, &ch);
+@@ -297,6 +299,7 @@ applyrules(Client *c)
+ 		&& (!r->class || strstr(class, r->class))
+ 		&& (!r->instance || strstr(instance, r->instance)))
+ 		{
++			c->iscentered = r->iscentered;
+ 			c->isfloating = r->isfloating;
+ 			c->tags |= r->tags;
+ 			for (m = mons; m && m->num != r->monitor; m = m->next);
+@@ -1056,6 +1059,10 @@ manage(Window w, XWindowAttributes *wa)
+ 	updatewindowtype(c);
+ 	updatesizehints(c);
+ 	updatewmhints(c);
++	if (c->iscentered) {
++		c->x = c->mon->mx + (c->mon->mw - WIDTH(c)) / 2;
++		c->y = c->mon->my + (c->mon->mh - HEIGHT(c)) / 2;
++	}
+ 	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
+ 	grabbuttons(c, 0);
+ 	if (!c->isfloating)
+@@ -2009,8 +2016,10 @@ updatewindowtype(Client *c)
+ 
+ 	if (state == netatom[NetWMFullscreen])
+ 		setfullscreen(c, 1);
+-	if (wtype == netatom[NetWMWindowTypeDialog])
++	if (wtype == netatom[NetWMWindowTypeDialog]) {
++		c->iscentered = 1;
+ 		c->isfloating = 1;
++	}
+ }
+ 
+ void
+-- 
+2.17.1
+
diff --git a/patches/dwm-fixborders-6.2.diff b/patches/dwm-fixborders-6.2.diff
new file mode 100644
index 0000000..0a17b9e
--- /dev/null
+++ b/patches/dwm-fixborders-6.2.diff
@@ -0,0 +1,27 @@
+From 1529909466206016f2101457bbf37c67195714c8 Mon Sep 17 00:00:00 2001
+From: Jakub Leszczak <szatan@gecc.xyz>
+Date: Fri, 22 Nov 2019 10:46:53 +0800
+Subject: [PATCH] Fix transparent borders
+
+When terminal has transparency then its borders also become transparent.
+Fix it by removing transparency from any pixels drawn.
+---
+ drw.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/drw.c b/drw.c
+index 8fd1ca4..490a592 100644
+--- a/drw.c
++++ b/drw.c
+@@ -202,6 +202,8 @@ drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
+ 	                       DefaultColormap(drw->dpy, drw->screen),
+ 	                       clrname, dest))
+ 		die("error, cannot allocate color '%s'", clrname);
++
++	dest->pixel |= 0xff << 24;
+ }
+ 
+ /* Wrapper to create color schemes. The caller has to call free(3) on the
+-- 
+2.26.2
+
diff --git a/patches/dwm-fullgaps-20200508-7b77734.diff b/patches/dwm-fullgaps-20200508-7b77734.diff
new file mode 100644
index 0000000..368c871
--- /dev/null
+++ b/patches/dwm-fullgaps-20200508-7b77734.diff
@@ -0,0 +1,138 @@
+From 7b7773458c072e4b24d6ea32d0364a8e402e4a43 Mon Sep 17 00:00:00 2001
+From: swy7ch <swy7ch@protonmail.com>
+Date: Fri, 8 May 2020 19:07:24 +0200
+Subject: [PATCH] [PATCH] update dwm-fullgaps patch to be used with tile layout
+ update
+
+the recent tile layout changes in commit HEAD~1 (f09418b) broke the
+patch
+
+this patch adapt the new `if` statements to take gaps into account
+
+this patch also provides manpage entries for the keybindings
+---
+ config.def.h |  4 ++++
+ dwm.1        | 10 ++++++++++
+ dwm.c        | 33 +++++++++++++++++++++++----------
+ 3 files changed, 37 insertions(+), 10 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index 1c0b587..38d2f6c 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -2,6 +2,7 @@
+ 
+ /* appearance */
+ static const unsigned int borderpx  = 1;        /* border pixel of windows */
++static const unsigned int gappx     = 5;        /* gaps between windows */
+ static const unsigned int snap      = 32;       /* snap pixel */
+ static const int showbar            = 1;        /* 0 means no bar */
+ static const int topbar             = 1;        /* 0 means bottom bar */
+@@ -84,6 +85,9 @@ static Key keys[] = {
+ 	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
+ 	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
+ 	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
++	{ MODKEY,                       XK_minus,  setgaps,        {.i = -1 } },
++	{ MODKEY,                       XK_equal,  setgaps,        {.i = +1 } },
++	{ MODKEY|ShiftMask,             XK_equal,  setgaps,        {.i = 0  } },
+ 	TAGKEYS(                        XK_1,                      0)
+ 	TAGKEYS(                        XK_2,                      1)
+ 	TAGKEYS(                        XK_3,                      2)
+diff --git a/dwm.1 b/dwm.1
+index 13b3729..0202d96 100644
+--- a/dwm.1
++++ b/dwm.1
+@@ -140,6 +140,16 @@ View all windows with any tag.
+ .B Mod1\-Control\-[1..n]
+ Add/remove all windows with nth tag to/from the view.
+ .TP
++.B Mod1\--
++Decrease the gaps around windows.
++.TP
++.B Mod1\-=
++Increase the gaps around windows.
++.TP
++.B Mod1\-Shift-=
++Reset the gaps around windows to
++.BR 0 .
++.TP
+ .B Mod1\-Shift\-q
+ Quit dwm.
+ .SS Mouse commands
+diff --git a/dwm.c b/dwm.c
+index 9fd0286..45a58f3 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -119,6 +119,7 @@ struct Monitor {
+ 	int by;               /* bar geometry */
+ 	int mx, my, mw, mh;   /* screen size */
+ 	int wx, wy, ww, wh;   /* window area  */
++	int gappx;            /* gaps between windows */
+ 	unsigned int seltags;
+ 	unsigned int sellt;
+ 	unsigned int tagset[2];
+@@ -200,6 +201,7 @@ static void sendmon(Client *c, Monitor *m);
+ static void setclientstate(Client *c, long state);
+ static void setfocus(Client *c);
+ static void setfullscreen(Client *c, int fullscreen);
++static void setgaps(const Arg *arg);
+ static void setlayout(const Arg *arg);
+ static void setmfact(const Arg *arg);
+ static void setup(void);
+@@ -639,6 +641,7 @@ createmon(void)
+ 	m->nmaster = nmaster;
+ 	m->showbar = showbar;
+ 	m->topbar = topbar;
++	m->gappx = gappx;
+ 	m->lt[0] = &layouts[0];
+ 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
+ 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
+@@ -1498,6 +1501,16 @@ setfullscreen(Client *c, int fullscreen)
+ 	}
+ }
+ 
++void
++setgaps(const Arg *arg)
++{
++	if ((arg->i == 0) || (selmon->gappx + arg->i < 0))
++		selmon->gappx = 0;
++	else
++		selmon->gappx += arg->i;
++	arrange(selmon);
++}
++
+ void
+ setlayout(const Arg *arg)
+ {
+@@ -1684,18 +1697,18 @@ tile(Monitor *m)
+ 	if (n > m->nmaster)
+ 		mw = m->nmaster ? m->ww * m->mfact : 0;
+ 	else
+-		mw = m->ww;
+-	for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
++		mw = m->ww - m->gappx;
++	for (i = 0, my = ty = m->gappx, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+ 		if (i < m->nmaster) {
+-			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
+-			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
+-			if (my + HEIGHT(c) < m->wh)
+-				my += HEIGHT(c);
++			h = (m->wh - my) / (MIN(n, m->nmaster) - i) - m->gappx;
++			resize(c, m->wx + m->gappx, m->wy + my, mw - (2*c->bw) - m->gappx, h - (2*c->bw), 0);
++			if (my + HEIGHT(c) + m->gappx < m->wh)
++				my += HEIGHT(c) + m->gappx;
+ 		} else {
+-			h = (m->wh - ty) / (n - i);
+-			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
+-			if (ty + HEIGHT(c) < m->wh)
+-				ty += HEIGHT(c);
++			h = (m->wh - ty) / (n - i) - m->gappx;
++			resize(c, m->wx + mw + m->gappx, m->wy + ty, m->ww - mw - (2*c->bw) - 2*m->gappx, h - (2*c->bw), 0);
++			if (ty + HEIGHT(c) + m->gappx < m->wh)
++				ty += HEIGHT(c) + m->gappx;
+ 		}
+ }
+ 
+-- 
+2.26.2
+
diff --git a/patches/dwm-integrated-status-text-6.3.diff b/patches/dwm-integrated-status-text-6.3.diff
new file mode 100644
index 0000000..02c8fd9
--- /dev/null
+++ b/patches/dwm-integrated-status-text-6.3.diff
@@ -0,0 +1,539 @@
+From 02f1f07ee4460787c971bd28e934cb5fc319253d Mon Sep 17 00:00:00 2001
+From: explosion-mental <explosion0mental@gmail.com>
+Date: Thu, 26 May 2022 22:34:14 -0500
+Subject: [PATCH] [PATCH] Allows dwm to handle the text by itself. You can
+ think of it like a dwmblocks integration into dwm itself. This is extracted
+ from my dwm build[0] in which you can find even more information.
+
+Example:
+```
+/* fg         command             interval  signal */
+{ "#000000",  "echo 'dwm block!",   10,       3},
+```
+
+- fg: the foreground color of the individual block, for the background it
+uses the bg of SchemeStatus.
+
+- command: it uses the output of the commands for the status text
+interval: in seconds, how much does it have to pass before updating the
+block.
+
+- interval: in seconds, how many seconds until the block it's updated
+
+- signal: have to be less than 30. This lets you update the block with
+`kill` by adding 35 to this value.
+For the block above it would be 34 + 3 = 37 -> `kill -37 $(pidof dwm)`.
+These signals are linux dependant.
+
+You can change `$(pidof dwm)` with `$STATUSBAR` to 'fix' signaling
+multiple instances of dwm, since this patch also wraps the PID of dwm
+into the `$STATUSBAR` enviromental variable.
+
+Last thing, mouse actions. For this you need to handle the env variable
+`$BLOCK_BUTTON` in a script, this is so you can easily reuse the scripts
+used in dwmblocks. And remember that mouse actions update the block.
+
+[0] https://github.com/explosion-mental/Dwm or
+https://codeberg.org/explosion-mental/Dwm
+---
+ config.def.h |  39 ++++++-
+ dwm.c        | 298 +++++++++++++++++++++++++++++++++++++++++++++++----
+ 2 files changed, 318 insertions(+), 19 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index a2ac963..cad178c 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -16,8 +16,38 @@ static const char *colors[][3]      = {
+ 	/*               fg         bg         border   */
+ 	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
+ 	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
++	[SchemeStatus]={ col_cyan, col_gray1,  NULL  },
+ };
+ 
++
++/* status bar */
++static const Block blocks[] = {
++	/* fg     command				interval	signal */
++	{ col_gray3, "sb-clock",			20,		1},
++	{ col_gray1, "sb-disk",				9000,		2},
++	{ col_gray2, "sb-battery",			10,		3},
++	{ col_gray3, "sb-internet",			10,		4},
++	{ col_cyan, "sb-mailbox",			0,		5},
++	{ "#000001", "sb-moonphase",			0,		6},
++	{ "#1F0077", "sb-forecast",			0,		7},
++	{ "#000077", "sb-volume",			0,		8},
++	{ "#F77000", "sb-pacpackages",			0,		9},
++	{ "#177000", "sb-sync",				0,		10},
++//	{ col_gray1, "sb-mpc",				0,		26},
++	{ col_gray2, "sb-music",			0,		11},
++//	{ col_gray3, "sb-tasks",			10,		12},
++	{ col_gray4, "sb-notes",			0,		13},
++	{ col_cyan, "echo '';cat /tmp/recordingicon",	0,		14},
++};
++
++/* inverse the order of the blocks, comment to disable */
++#define INVERSED	1
++/* delimeter between blocks commands. NULL character ('\0') means no delimeter. */
++static char delimiter[] = " ";
++/* max number of character that one block command can output */
++#define CMDLENGTH	50
++
++
+ /* tagging */
+ static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+ 
+@@ -104,7 +134,14 @@ static Button buttons[] = {
+ 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
+ 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
+ 	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
+-	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
++
++	{ ClkStatusText,        0,              Button1,        sendstatusbar,   {.i = 1 } },
++	{ ClkStatusText,        0,              Button2,        sendstatusbar,   {.i = 2 } },
++	{ ClkStatusText,        0,              Button3,        sendstatusbar,   {.i = 3 } },
++	{ ClkStatusText,        0,              Button4,        sendstatusbar,   {.i = 4 } },
++	{ ClkStatusText,        0,              Button5,        sendstatusbar,   {.i = 5 } },
++	{ ClkStatusText,        ShiftMask,      Button1,        sendstatusbar,   {.i = 6 } },
++
+ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+ 	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
+diff --git a/dwm.c b/dwm.c
+index a96f33c..5789f72 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -28,6 +28,7 @@
+ #include <stdlib.h>
+ #include <string.h>
+ #include <unistd.h>
++#include <poll.h>
+ #include <sys/types.h>
+ #include <sys/wait.h>
+ #include <X11/cursorfont.h>
+@@ -59,7 +60,7 @@
+ 
+ /* enums */
+ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+-enum { SchemeNorm, SchemeSel }; /* color schemes */
++enum { SchemeNorm, SchemeSel, SchemeStatus }; /* color schemes */
+ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
+        NetWMFullscreen, NetActiveWindow, NetWMWindowType,
+        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
+@@ -141,6 +142,13 @@ typedef struct {
+ 	int monitor;
+ } Rule;
+ 
++typedef struct {
++	const char *color;
++	const char *command;
++	const unsigned int interval;
++	const unsigned int signal;
++} Block;
++
+ /* function declarations */
+ static void applyrules(Client *c);
+ static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
+@@ -172,6 +180,11 @@ static void focusstack(const Arg *arg);
+ static Atom getatomprop(Client *c, Atom prop);
+ static int getrootptr(int *x, int *y);
+ static long getstate(Window w);
++static void getcmd(int i, char *button);
++static void getcmds(int time);
++static void getsigcmds(int signal);
++static int gcd(int a, int b);
++static int getstatus(int width);
+ static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
+ static void grabbuttons(Client *c, int focused);
+ static void grabkeys(void);
+@@ -197,14 +210,17 @@ static void run(void);
+ static void scan(void);
+ static int sendevent(Client *c, Atom proto);
+ static void sendmon(Client *c, Monitor *m);
++static void sendstatusbar(const Arg *arg);
+ static void setclientstate(Client *c, long state);
+ static void setfocus(Client *c);
+ static void setfullscreen(Client *c, int fullscreen);
+ static void setlayout(const Arg *arg);
+ static void setmfact(const Arg *arg);
+ static void setup(void);
++static void setsignal(int sig, void (*handler)(int sig));
+ static void seturgent(Client *c, int urg);
+ static void showhide(Client *c);
++static void sigalrm(int unused);
+ static void sigchld(int unused);
+ static void spawn(const Arg *arg);
+ static void tag(const Arg *arg);
+@@ -237,13 +253,16 @@ static void zoom(const Arg *arg);
+ 
+ /* variables */
+ static const char broken[] = "broken";
+-static char stext[256];
+ static int screen;
+ static int sw, sh;           /* X display screen geometry width, height */
+ static int bh, blw = 0;      /* bar geometry */
+ static int lrpad;            /* sum of left and right padding for text */
+ static int (*xerrorxlib)(Display *, XErrorEvent *);
++static unsigned int blocknum; /* blocks idx in mouse click */
++static unsigned int stsw = 0; /* status width */
+ static unsigned int numlockmask = 0;
++static unsigned int sleepinterval = 0, maxinterval = 0, count = 0;
++static unsigned int execlock = 0; /* ensure only one child process exists per block at an instance */
+ static void (*handler[LASTEvent]) (XEvent *) = {
+ 	[ButtonPress] = buttonpress,
+ 	[ClientMessage] = clientmessage,
+@@ -272,6 +291,9 @@ static Window root, wmcheckwin;
+ /* configuration, allows nested code to access above variables */
+ #include "config.h"
+ 
++static char blockoutput[LENGTH(blocks)][CMDLENGTH + 1] = {0};
++static int pipes[LENGTH(blocks)][2];
++
+ /* compile-time check if all tags fit into an unsigned int bit array. */
+ struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
+ 
+@@ -440,9 +462,26 @@ buttonpress(XEvent *e)
+ 			arg.ui = 1 << i;
+ 		} else if (ev->x < x + blw)
+ 			click = ClkLtSymbol;
+-		else if (ev->x > selmon->ww - (int)TEXTW(stext))
++		else if (ev->x > (x = selmon->ww - stsw)) {
+ 			click = ClkStatusText;
+-		else
++			int len, i;
++
++			#if INVERSED
++			for (i = LENGTH(blocks) - 1; i >= 0; i--)
++			#else
++			for (i = 0; i < LENGTH(blocks); i++)
++			#endif /* INVERSED */
++			{
++				if (*blockoutput[i] == '\0') /* ignore command that output NULL or '\0' */
++					continue;
++				len = TEXTW(blockoutput[i]) - lrpad + TEXTW(delimiter) - lrpad;
++				x += len;
++				if (ev->x <= x && ev->x >= x - len) { /* if the mouse is between the block area */
++					blocknum = i; /* store what block the mouse is clicking */
++					break;
++				}
++			}
++		} else
+ 			click = ClkWinTitle;
+ 	} else if ((c = wintoclient(ev->window))) {
+ 		focus(c);
+@@ -706,11 +745,8 @@ drawbar(Monitor *m)
+ 		return;
+ 
+ 	/* draw status first so it can be overdrawn by tags later */
+-	if (m == selmon) { /* status is only drawn on selected monitor */
+-		drw_setscheme(drw, scheme[SchemeNorm]);
+-		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
+-		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
+-	}
++	if (m == selmon) /* status is only drawn on selected monitor */
++		tw = getstatus(m->ww);
+ 
+ 	for (c = m->clients; c; c = c->next) {
+ 		occ |= c->tags;
+@@ -903,6 +939,106 @@ getstate(Window w)
+ 	return result;
+ }
+ 
++void
++getcmd(int i, char *button)
++{
++	if (!selmon->showbar)
++		return;
++
++	if (execlock & 1 << i) { /* block is already running */
++		//fprintf(stderr, "dwm: ignoring block %d, command %s\n", i, blocks[i].command);
++		return;
++	}
++
++	/* lock execution of block until current instance finishes execution */
++	execlock |= 1 << i;
++
++	if (fork() == 0) {
++		if (dpy)
++			close(ConnectionNumber(dpy));
++		dup2(pipes[i][1], STDOUT_FILENO);
++		close(pipes[i][0]);
++		close(pipes[i][1]);
++
++		if (button)
++			setenv("BLOCK_BUTTON", button, 1);
++		execlp("/bin/sh", "sh", "-c", blocks[i].command, (char *) NULL);
++		fprintf(stderr, "dwm: block %d, execlp %s", i, blocks[i].command);
++		perror(" failed");
++		exit(EXIT_SUCCESS);
++	}
++}
++
++void
++getcmds(int time)
++{
++	int i;
++	for (i = 0; i < LENGTH(blocks); i++)
++		if ((blocks[i].interval != 0 && time % blocks[i].interval == 0) || time == -1)
++			getcmd(i, NULL);
++}
++
++void
++getsigcmds(int signal)
++{
++	int i;
++	unsigned int sig = signal - SIGRTMIN;
++	for (i = 0; i < LENGTH(blocks); i++)
++		if (blocks[i].signal == sig)
++			getcmd(i, NULL);
++}
++
++int
++getstatus(int width)
++{
++	int i, len, all = width, delimlen = TEXTW(delimiter) - lrpad;
++	char fgcol[8];
++				/* fg		bg */
++	const char *cols[8] = 	{ fgcol, colors[SchemeStatus][ColBg] };
++	//uncomment to inverse the colors
++	//const char *cols[8] = 	{ colors[SchemeStatus][ColBg], fgcol };
++
++	#if INVERSED
++	for (i = 0; i < LENGTH(blocks); i++)
++	#else
++	for (i = LENGTH(blocks) - 1; i >= 0; i--)
++	#endif /* INVERSED */
++	{
++		if (*blockoutput[i] == '\0') /* ignore command that output NULL or '\0' */
++			continue;
++		strncpy(fgcol, blocks[i].color, 8);
++		/* re-load the scheme with the new colors */
++		scheme[SchemeStatus] = drw_scm_create(drw, cols, 3);
++		drw_setscheme(drw, scheme[SchemeStatus]); /* 're-set' the scheme */
++		len = TEXTW(blockoutput[i]) - lrpad;
++		all -= len;
++		drw_text(drw, all, 0, len, bh, 0, blockoutput[i], 0);
++		/* draw delimiter */
++		if (*delimiter == '\0') /* ignore no delimiter */
++			continue;
++		drw_setscheme(drw, scheme[SchemeNorm]);
++		all -= delimlen;
++		drw_text(drw, all, 0, delimlen, bh, 0, delimiter, 0);
++	}
++
++	return stsw = width - all;
++}
++
++int
++gcd(int a, int b)
++{
++	int temp;
++
++	while (b > 0) {
++		temp = a % b;
++		a = b;
++		b = temp;
++	}
++
++	return a;
++}
++
++
+ int
+ gettextprop(Window w, Atom atom, char *text, unsigned int size)
+ {
+@@ -1376,12 +1512,99 @@ restack(Monitor *m)
+ void
+ run(void)
+ {
++	int i;
+ 	XEvent ev;
++	struct pollfd fds[LENGTH(blocks) + 1] = {0};
++
++	fds[0].fd = ConnectionNumber(dpy);
++	fds[0].events = POLLIN;
++
++	#if INVERSED
++	for (i = LENGTH(blocks) - 1; i >= 0; i--)
++	#else
++	for (i = 0; i < LENGTH(blocks); i++)
++	#endif /* INVERSED */
++	{
++		pipe(pipes[i]);
++		fds[i + 1].fd = pipes[i][0];
++		fds[i + 1].events = POLLIN;
++		getcmd(i, NULL);
++		if (blocks[i].interval) {
++			maxinterval = MAX(blocks[i].interval, maxinterval);
++			sleepinterval = gcd(blocks[i].interval, sleepinterval);
++		}
++	}
++
++	alarm(sleepinterval);
+ 	/* main event loop */
+ 	XSync(dpy, False);
+-	while (running && !XNextEvent(dpy, &ev))
+-		if (handler[ev.type])
+-			handler[ev.type](&ev); /* call handler */
++	while (running) {
++
++		/* bar hidden, then skip poll */
++		if (!selmon->showbar) {
++			XNextEvent(dpy, &ev);
++			if (handler[ev.type])
++				handler[ev.type](&ev); /* call handler */
++			continue;
++		}
++
++		if ((poll(fds, LENGTH(blocks) + 1, -1)) == -1) {
++			/* FIXME other than SIGALRM and the real time signals,
++			 * there seems to be a signal being que if using
++			 * 'xsetroot -name' sutff */
++			if (errno == EINTR) /* signal caught */
++				continue;
++			fprintf(stderr, "dwm: poll ");
++			perror("failed");
++			exit(EXIT_FAILURE);
++		}
++
++		/* handle display fd */
++		if (fds[0].revents & POLLIN) {
++			while (running && XPending(dpy)) {
++				XNextEvent(dpy, &ev);
++				if (handler[ev.type])
++					handler[ev.type](&ev); /* call handler */
++			}
++		} else if (fds[0].revents & POLLHUP) {
++			fprintf(stderr, "dwm: main event loop, hang up");
++			perror(" failed");
++			exit(EXIT_FAILURE);
++		}
++
++		/* handle blocks */
++		for (i = 0; i < LENGTH(blocks); i++) {
++			if (fds[i + 1].revents & POLLIN) {
++				/* empty buffer with CMDLENGTH + 1 byte for the null terminator */
++				int bt = read(fds[i + 1].fd, blockoutput[i], CMDLENGTH);
++				/* remove lock for the current block */
++				execlock &= ~(1 << i);
++
++				if (bt == -1) { /* if read failed */
++					fprintf(stderr, "dwm: read failed in block %s\n", blocks[i].command);
++					perror(" failed");
++					continue;
++				}
++
++				if (blockoutput[i][bt - 1] == '\n') /* chop off ending new line, if one is present */
++					blockoutput[i][bt - 1] = '\0';
++				else /* NULL terminate the string */
++					blockoutput[i][bt++] = '\0';
++
++				drawbar(selmon);
++			} else if (fds[i + 1].revents & POLLHUP) {
++				fprintf(stderr, "dwm: block %d hangup", i);
++				perror(" failed");
++				exit(EXIT_FAILURE);
++			}
++		}
++	}
++
++	/* close the pipes after running */
++	for (i = 0; i < LENGTH(blocks); i++) {
++		close(pipes[i][0]);
++		close(pipes[i][1]);
++	}
+ }
+ 
+ void
+@@ -1427,6 +1650,13 @@ sendmon(Client *c, Monitor *m)
+ 	arrange(NULL);
+ }
+ 
++void
++sendstatusbar(const Arg *arg)
++{
++	char button[2] = { '0' + arg->i & 0xff, '\0' };
++	getcmd(blocknum, button);
++}
++
+ void
+ setclientstate(Client *c, long state)
+ {
+@@ -1537,8 +1767,20 @@ setup(void)
+ 	XSetWindowAttributes wa;
+ 	Atom utf8string;
+ 
+-	/* clean up any zombies immediately */
+-	sigchld(0);
++	setsignal(SIGCHLD, sigchld); /* zombies */
++	setsignal(SIGALRM, sigalrm); /* timer */
++
++	#ifdef __linux__
++	/* handle defined real time signals (linux only) */
++	for (i = 0; i < LENGTH(blocks); i++)
++		if (blocks[i].signal)
++			setsignal(SIGRTMIN + blocks[i].signal, getsigcmds);
++	#endif /* __linux__ */
++
++	/* pid as an enviromental variable */
++	char envpid[16];
++	snprintf(envpid, LENGTH(envpid), "%d", getpid());
++	setenv("STATUSBAR", envpid, 1);
+ 
+ 	/* init screen */
+ 	screen = DefaultScreen(dpy);
+@@ -1600,6 +1842,21 @@ setup(void)
+ 	focus(NULL);
+ }
+ 
++void
++setsignal(int sig, void (*handler)(int unused))
++{
++	struct sigaction sa;
++
++	sa.sa_handler = handler;
++	sigemptyset(&sa.sa_mask);
++	sa.sa_flags = SA_NOCLDSTOP | SA_RESTART;
++
++	if (sigaction(sig, &sa, 0) == -1) {
++		fprintf(stderr, "signal %d ", sig);
++		perror("failed to setup");
++		exit(EXIT_FAILURE);
++	}
++}
+ 
+ void
+ seturgent(Client *c, int urg)
+@@ -1632,11 +1889,18 @@ showhide(Client *c)
+ 	}
+ }
+ 
++
++void
++sigalrm(int unused)
++{
++	getcmds(count);
++	alarm(sleepinterval);
++	count = (count + sleepinterval - 1) % maxinterval + 1;
++}
++
+ void
+ sigchld(int unused)
+ {
+-	if (signal(SIGCHLD, sigchld) == SIG_ERR)
+-		die("can't install SIGCHLD handler:");
+ 	while (0 < waitpid(-1, NULL, WNOHANG));
+ }
+ 
+@@ -1993,8 +2257,6 @@ updatesizehints(Client *c)
+ void
+ updatestatus(void)
+ {
+-	if (!gettextprop(root, XA_WM_NAME, stext, sizeof(stext)))
+-		strcpy(stext, "dwm-"VERSION);
+ 	drawbar(selmon);
+ }
+ 
+-- 
+2.36.1
+
diff --git a/patches/dwm-notitle-20210715-138b405.diff b/patches/dwm-notitle-20210715-138b405.diff
new file mode 100644
index 0000000..bc8a3e5
--- /dev/null
+++ b/patches/dwm-notitle-20210715-138b405.diff
@@ -0,0 +1,81 @@
+From a3a7e94f59553689656871a65ea9ce90169a7c91 Mon Sep 17 00:00:00 2001
+From: birdalicous <jack.bird@durham.ac.uk>
+Date: Thu, 15 Jul 2021 12:28:29 +0100
+Subject: [PATCH] notitle patch applied#
+
+---
+ config.def.h |  1 -
+ dwm.c        | 20 ++++----------------
+ 2 files changed, 4 insertions(+), 17 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index a2ac963..eac20b4 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -103,7 +103,6 @@ static Button buttons[] = {
+ 	/* click                event mask      button          function        argument */
+ 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
+ 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
+-	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
+ 	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
+ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+diff --git a/dwm.c b/dwm.c
+index 5e4d494..6cd9fb7 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -64,8 +64,8 @@ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
+        NetWMFullscreen, NetActiveWindow, NetWMWindowType,
+        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
+ enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
+-enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
+-       ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
++enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkClientWin,
++       ClkRootWin, ClkLast }; /* clicks */
+ 
+ typedef union {
+ 	int i;
+@@ -440,10 +440,8 @@ buttonpress(XEvent *e)
+ 			arg.ui = 1 << i;
+ 		} else if (ev->x < x + blw)
+ 			click = ClkLtSymbol;
+-		else if (ev->x > selmon->ww - (int)TEXTW(stext))
+-			click = ClkStatusText;
+ 		else
+-			click = ClkWinTitle;
++			click = ClkStatusText;
+ 	} else if ((c = wintoclient(ev->window))) {
+ 		focus(c);
+ 		restack(selmon);
+@@ -730,15 +728,8 @@ drawbar(Monitor *m)
+ 	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
+ 
+ 	if ((w = m->ww - tw - x) > bh) {
+-		if (m->sel) {
+-			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
+-			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
+-			if (m->sel->isfloating)
+-				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
+-		} else {
+ 			drw_setscheme(drw, scheme[SchemeNorm]);
+ 			drw_rect(drw, x, 0, w, bh, 1, 1);
+-		}
+ 	}
+ 	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
+ }
+@@ -1236,11 +1227,8 @@ propertynotify(XEvent *e)
+ 			drawbars();
+ 			break;
+ 		}
+-		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]) {
++		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName])
+ 			updatetitle(c);
+-			if (c == c->mon->sel)
+-				drawbar(c->mon);
+-		}
+ 		if (ev->atom == netatom[NetWMWindowType])
+ 			updatewindowtype(c);
+ 	}
+-- 
+2.32.0
+
diff --git a/patches/dwm-pertag-20200914-61bb8b2.diff b/patches/dwm-pertag-20200914-61bb8b2.diff
new file mode 100644
index 0000000..c8d7fbc
--- /dev/null
+++ b/patches/dwm-pertag-20200914-61bb8b2.diff
@@ -0,0 +1,177 @@
+diff --git a/dwm.c b/dwm.c
+index 664c527..ac8e4ec 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -111,6 +111,7 @@ typedef struct {
+ 	void (*arrange)(Monitor *);
+ } Layout;
+ 
++typedef struct Pertag Pertag;
+ struct Monitor {
+ 	char ltsymbol[16];
+ 	float mfact;
+@@ -130,6 +131,7 @@ struct Monitor {
+ 	Monitor *next;
+ 	Window barwin;
+ 	const Layout *lt[2];
++	Pertag *pertag;
+ };
+ 
+ typedef struct {
+@@ -272,6 +274,15 @@ static Window root, wmcheckwin;
+ /* configuration, allows nested code to access above variables */
+ #include "config.h"
+ 
++struct Pertag {
++	unsigned int curtag, prevtag; /* current and previous tag */
++	int nmasters[LENGTH(tags) + 1]; /* number of windows in master area */
++	float mfacts[LENGTH(tags) + 1]; /* mfacts per tag */
++	unsigned int sellts[LENGTH(tags) + 1]; /* selected layouts */
++	const Layout *ltidxs[LENGTH(tags) + 1][2]; /* matrix of tags and layouts indexes  */
++	int showbars[LENGTH(tags) + 1]; /* display bar for the current tag */
++};
++
+ /* compile-time check if all tags fit into an unsigned int bit array. */
+ struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
+ 
+@@ -632,6 +643,7 @@ Monitor *
+ createmon(void)
+ {
+ 	Monitor *m;
++	unsigned int i;
+ 
+ 	m = ecalloc(1, sizeof(Monitor));
+ 	m->tagset[0] = m->tagset[1] = 1;
+@@ -642,6 +654,20 @@ createmon(void)
+ 	m->lt[0] = &layouts[0];
+ 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
+ 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
++	m->pertag = ecalloc(1, sizeof(Pertag));
++	m->pertag->curtag = m->pertag->prevtag = 1;
++
++	for (i = 0; i <= LENGTH(tags); i++) {
++		m->pertag->nmasters[i] = m->nmaster;
++		m->pertag->mfacts[i] = m->mfact;
++
++		m->pertag->ltidxs[i][0] = m->lt[0];
++		m->pertag->ltidxs[i][1] = m->lt[1];
++		m->pertag->sellts[i] = m->sellt;
++
++		m->pertag->showbars[i] = m->showbar;
++	}
++
+ 	return m;
+ }
+ 
+@@ -967,7 +993,7 @@ grabkeys(void)
+ void
+ incnmaster(const Arg *arg)
+ {
+-	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
++	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag] = MAX(selmon->nmaster + arg->i, 0);
+ 	arrange(selmon);
+ }
+ 
+@@ -1502,9 +1528,9 @@ void
+ setlayout(const Arg *arg)
+ {
+ 	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
+-		selmon->sellt ^= 1;
++		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag] ^= 1;
+ 	if (arg && arg->v)
+-		selmon->lt[selmon->sellt] = (Layout *)arg->v;
++		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt] = (Layout *)arg->v;
+ 	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
+ 	if (selmon->sel)
+ 		arrange(selmon);
+@@ -1523,7 +1549,7 @@ setmfact(const Arg *arg)
+ 	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
+ 	if (f < 0.05 || f > 0.95)
+ 		return;
+-	selmon->mfact = f;
++	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag] = f;
+ 	arrange(selmon);
+ }
+ 
+@@ -1702,7 +1728,7 @@ tile(Monitor *m)
+ void
+ togglebar(const Arg *arg)
+ {
+-	selmon->showbar = !selmon->showbar;
++	selmon->showbar = selmon->pertag->showbars[selmon->pertag->curtag] = !selmon->showbar;
+ 	updatebarpos(selmon);
+ 	XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
+ 	arrange(selmon);
+@@ -1741,9 +1767,33 @@ void
+ toggleview(const Arg *arg)
+ {
+ 	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
++	int i;
+ 
+ 	if (newtagset) {
+ 		selmon->tagset[selmon->seltags] = newtagset;
++
++		if (newtagset == ~0) {
++			selmon->pertag->prevtag = selmon->pertag->curtag;
++			selmon->pertag->curtag = 0;
++		}
++
++		/* test if the user did not select the same tag */
++		if (!(newtagset & 1 << (selmon->pertag->curtag - 1))) {
++			selmon->pertag->prevtag = selmon->pertag->curtag;
++			for (i = 0; !(newtagset & 1 << i); i++) ;
++			selmon->pertag->curtag = i + 1;
++		}
++
++		/* apply settings for this view */
++		selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
++		selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
++		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
++		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
++		selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
++
++		if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
++			togglebar(NULL);
++
+ 		focus(NULL);
+ 		arrange(selmon);
+ 	}
+@@ -2038,11 +2088,37 @@ updatewmhints(Client *c)
+ void
+ view(const Arg *arg)
+ {
++	int i;
++	unsigned int tmptag;
++
+ 	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
+ 		return;
+ 	selmon->seltags ^= 1; /* toggle sel tagset */
+-	if (arg->ui & TAGMASK)
++	if (arg->ui & TAGMASK) {
+ 		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
++		selmon->pertag->prevtag = selmon->pertag->curtag;
++
++		if (arg->ui == ~0)
++			selmon->pertag->curtag = 0;
++		else {
++			for (i = 0; !(arg->ui & 1 << i); i++) ;
++			selmon->pertag->curtag = i + 1;
++		}
++	} else {
++		tmptag = selmon->pertag->prevtag;
++		selmon->pertag->prevtag = selmon->pertag->curtag;
++		selmon->pertag->curtag = tmptag;
++	}
++
++	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
++	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
++	selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
++	selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
++	selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
++
++	if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
++		togglebar(NULL);
++
+ 	focus(NULL);
+ 	arrange(selmon);
+ }
diff --git a/patches/dwm-restartsig-20180523-6.2.diff b/patches/dwm-restartsig-20180523-6.2.diff
new file mode 100644
index 0000000..f1f8680
--- /dev/null
+++ b/patches/dwm-restartsig-20180523-6.2.diff
@@ -0,0 +1,139 @@
+From 2991f37f0aaf44b9f9b11e7893ff0af8eb88f649 Mon Sep 17 00:00:00 2001
+From: Christopher Drelich <cd@cdrakka.com>
+Date: Wed, 23 May 2018 22:50:38 -0400
+Subject: [PATCH] Modifies quit to handle restarts and adds SIGHUP and SIGTERM
+ handlers.
+
+Modified quit() to restart if it receives arg .i = 1
+MOD+CTRL+SHIFT+Q was added to confid.def.h to do just that.
+
+Signal handlers were handled for SIGHUP and SIGTERM.
+If dwm receives these signals it calls quit() with
+arg .i = to 1 or 0, respectively.
+
+To restart dwm:
+MOD+CTRL+SHIFT+Q
+or
+kill -HUP dwmpid
+
+To quit dwm cleanly:
+MOD+SHIFT+Q
+or
+kill -TERM dwmpid
+---
+ config.def.h |  1 +
+ dwm.1        | 10 ++++++++++
+ dwm.c        | 22 ++++++++++++++++++++++
+ 3 files changed, 33 insertions(+)
+
+diff --git a/config.def.h b/config.def.h
+index a9ac303..e559429 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -94,6 +94,7 @@ static Key keys[] = {
+ 	TAGKEYS(                        XK_8,                      7)
+ 	TAGKEYS(                        XK_9,                      8)
+ 	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
++	{ MODKEY|ControlMask|ShiftMask, XK_q,      quit,           {1} }, 
+ };
+ 
+ /* button definitions */
+diff --git a/dwm.1 b/dwm.1
+index 13b3729..36a331c 100644
+--- a/dwm.1
++++ b/dwm.1
+@@ -142,6 +142,9 @@ Add/remove all windows with nth tag to/from the view.
+ .TP
+ .B Mod1\-Shift\-q
+ Quit dwm.
++.TP
++.B Mod1\-Control\-Shift\-q
++Restart dwm.
+ .SS Mouse commands
+ .TP
+ .B Mod1\-Button1
+@@ -155,6 +158,13 @@ Resize focused window while dragging. Tiled windows will be toggled to the float
+ .SH CUSTOMIZATION
+ dwm is customized by creating a custom config.h and (re)compiling the source
+ code. This keeps it fast, secure and simple.
++.SH SIGNALS
++.TP
++.B SIGHUP - 1
++Restart the dwm process.
++.TP
++.B SIGTERM - 15
++Cleanly terminate the dwm process.
+ .SH SEE ALSO
+ .BR dmenu (1),
+ .BR st (1)
+diff --git a/dwm.c b/dwm.c
+index bb95e26..286eecd 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -205,6 +205,8 @@ static void setup(void);
+ static void seturgent(Client *c, int urg);
+ static void showhide(Client *c);
+ static void sigchld(int unused);
++static void sighup(int unused);
++static void sigterm(int unused);
+ static void spawn(const Arg *arg);
+ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
+@@ -260,6 +262,7 @@ static void (*handler[LASTEvent]) (XEvent *) = {
+ 	[UnmapNotify] = unmapnotify
+ };
+ static Atom wmatom[WMLast], netatom[NetLast];
++static int restart = 0;
+ static int running = 1;
+ static Cur *cursor[CurLast];
+ static Clr **scheme;
+@@ -1248,6 +1251,7 @@ propertynotify(XEvent *e)
+ void
+ quit(const Arg *arg)
+ {
++	if(arg->i) restart = 1;
+ 	running = 0;
+ }
+ 
+@@ -1536,6 +1540,9 @@ setup(void)
+ 	/* clean up any zombies immediately */
+ 	sigchld(0);
+ 
++	signal(SIGHUP, sighup);
++	signal(SIGTERM, sigterm);
++
+ 	/* init screen */
+ 	screen = DefaultScreen(dpy);
+ 	sw = DisplayWidth(dpy, screen);
+@@ -1637,6 +1644,20 @@ sigchld(int unused)
+ }
+ 
+ void
++sighup(int unused)
++{
++	Arg a = {.i = 1};
++	quit(&a);
++}
++
++void
++sigterm(int unused)
++{
++	Arg a = {.i = 0};
++	quit(&a);
++}
++
++void
+ spawn(const Arg *arg)
+ {
+ 	if (arg->v == dmenucmd)
+@@ -2139,6 +2160,7 @@ main(int argc, char *argv[])
+ 	setup();
+ 	scan();
+ 	run();
++	if(restart) execvp(argv[0], argv);
+ 	cleanup();
+ 	XCloseDisplay(dpy);
+ 	return EXIT_SUCCESS;
+-- 
+2.7.4
+
diff --git a/patches/dwm-status2d-20200508-60bb3df.diff b/patches/dwm-status2d-20200508-60bb3df.diff
new file mode 100644
index 0000000..6f353fd
--- /dev/null
+++ b/patches/dwm-status2d-20200508-60bb3df.diff
@@ -0,0 +1,180 @@
+From 60bb3dfaf91227eb02e828d74e6f4758b2c56542 Mon Sep 17 00:00:00 2001
+From: cultab <rroarck@gmail.com>
+Date: Fri, 8 May 2020 13:56:08 +0300
+Subject: [PATCH] fix status2d to work after ed3ab6
+
+ed3ab6 changed the name of the variable sw to tw, now the patch won't apply nor work.
+This patch updates the variable name to the new one.
+---
+ dwm.c | 120 +++++++++++++++++++++++++++++++++++++++++++++++++++++++---
+ 1 file changed, 114 insertions(+), 6 deletions(-)
+
+diff --git a/dwm.c b/dwm.c
+index 9fd0286..71e18be 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -163,6 +163,7 @@ static void detachstack(Client *c);
+ static Monitor *dirtomon(int dir);
+ static void drawbar(Monitor *m);
+ static void drawbars(void);
++static int drawstatusbar(Monitor *m, int bh, char* text);
+ static void enternotify(XEvent *e);
+ static void expose(XEvent *e);
+ static void focus(Client *c);
+@@ -237,7 +238,7 @@ static void zoom(const Arg *arg);
+ 
+ /* variables */
+ static const char broken[] = "broken";
+-static char stext[256];
++static char stext[1024];
+ static int screen;
+ static int sw, sh;           /* X display screen geometry width, height */
+ static int bh, blw = 0;      /* bar geometry */
+@@ -485,7 +486,7 @@ cleanup(void)
+ 		cleanupmon(mons);
+ 	for (i = 0; i < CurLast; i++)
+ 		drw_cur_free(drw, cursor[i]);
+-	for (i = 0; i < LENGTH(colors); i++)
++	for (i = 0; i < LENGTH(colors) + 1; i++)
+ 		free(scheme[i]);
+ 	XDestroyWindow(dpy, wmcheckwin);
+ 	drw_free(drw);
+@@ -693,6 +694,114 @@ dirtomon(int dir)
+ 	return m;
+ }
+ 
++int
++drawstatusbar(Monitor *m, int bh, char* stext) {
++	int ret, i, w, x, len;
++	short isCode = 0;
++	char *text;
++	char *p;
++
++	len = strlen(stext) + 1 ;
++	if (!(text = (char*) malloc(sizeof(char)*len)))
++		die("malloc");
++	p = text;
++	memcpy(text, stext, len);
++
++	/* compute width of the status text */
++	w = 0;
++	i = -1;
++	while (text[++i]) {
++		if (text[i] == '^') {
++			if (!isCode) {
++				isCode = 1;
++				text[i] = '\0';
++				w += TEXTW(text) - lrpad;
++				text[i] = '^';
++				if (text[++i] == 'f')
++					w += atoi(text + ++i);
++			} else {
++				isCode = 0;
++				text = text + i + 1;
++				i = -1;
++			}
++		}
++	}
++	if (!isCode)
++		w += TEXTW(text) - lrpad;
++	else
++		isCode = 0;
++	text = p;
++
++	w += 2; /* 1px padding on both sides */
++	ret = x = m->ww - w;
++
++	drw_setscheme(drw, scheme[LENGTH(colors)]);
++	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++	drw_rect(drw, x, 0, w, bh, 1, 1);
++	x++;
++
++	/* process status text */
++	i = -1;
++	while (text[++i]) {
++		if (text[i] == '^' && !isCode) {
++			isCode = 1;
++
++			text[i] = '\0';
++			w = TEXTW(text) - lrpad;
++			drw_text(drw, x, 0, w, bh, 0, text, 0);
++
++			x += w;
++
++			/* process code */
++			while (text[++i] != '^') {
++				if (text[i] == 'c') {
++					char buf[8];
++					memcpy(buf, (char*)text+i+1, 7);
++					buf[7] = '\0';
++					drw_clr_create(drw, &drw->scheme[ColFg], buf);
++					i += 7;
++				} else if (text[i] == 'b') {
++					char buf[8];
++					memcpy(buf, (char*)text+i+1, 7);
++					buf[7] = '\0';
++					drw_clr_create(drw, &drw->scheme[ColBg], buf);
++					i += 7;
++				} else if (text[i] == 'd') {
++					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++				} else if (text[i] == 'r') {
++					int rx = atoi(text + ++i);
++					while (text[++i] != ',');
++					int ry = atoi(text + ++i);
++					while (text[++i] != ',');
++					int rw = atoi(text + ++i);
++					while (text[++i] != ',');
++					int rh = atoi(text + ++i);
++
++					drw_rect(drw, rx + x, ry, rw, rh, 1, 0);
++				} else if (text[i] == 'f') {
++					x += atoi(text + ++i);
++				}
++			}
++
++			text = text + i + 1;
++			i=-1;
++			isCode = 0;
++		}
++	}
++
++	if (!isCode) {
++		w = TEXTW(text) - lrpad;
++		drw_text(drw, x, 0, w, bh, 0, text, 0);
++	}
++
++	drw_setscheme(drw, scheme[SchemeNorm]);
++	free(p);
++
++	return ret;
++}
++
+ void
+ drawbar(Monitor *m)
+ {
+@@ -704,9 +813,7 @@ drawbar(Monitor *m)
+ 
+ 	/* draw status first so it can be overdrawn by tags later */
+ 	if (m == selmon) { /* status is only drawn on selected monitor */
+-		drw_setscheme(drw, scheme[SchemeNorm]);
+-		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
+-		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
++		tw = m->ww - drawstatusbar(m, bh, stext);
+ 	}
+ 
+ 	for (c = m->clients; c; c = c->next) {
+@@ -1568,7 +1675,8 @@ setup(void)
+ 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
+ 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
+ 	/* init appearance */
+-	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
++	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
++	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
+ 	for (i = 0; i < LENGTH(colors); i++)
+ 		scheme[i] = drw_scm_create(drw, colors[i], 3);
+ 	/* init bars */
+-- 
+2.26.2
+
diff --git a/patches/dwm-status2d-6.3.diff b/patches/dwm-status2d-6.3.diff
new file mode 100644
index 0000000..52bf58d
--- /dev/null
+++ b/patches/dwm-status2d-6.3.diff
@@ -0,0 +1,166 @@
+diff --git a/dwm.c b/dwm.c
+index a96f33c..24b1eeb 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -163,6 +163,7 @@ static void detachstack(Client *c);
+ static Monitor *dirtomon(int dir);
+ static void drawbar(Monitor *m);
+ static void drawbars(void);
++static int drawstatusbar(Monitor *m, int bh, char* text);
+ static void enternotify(XEvent *e);
+ static void expose(XEvent *e);
+ static void focus(Client *c);
+@@ -237,7 +238,7 @@ static void zoom(const Arg *arg);
+ 
+ /* variables */
+ static const char broken[] = "broken";
+-static char stext[256];
++static char stext[1024];
+ static int screen;
+ static int sw, sh;           /* X display screen geometry width, height */
+ static int bh, blw = 0;      /* bar geometry */
+@@ -485,7 +486,7 @@ cleanup(void)
+ 		cleanupmon(mons);
+ 	for (i = 0; i < CurLast; i++)
+ 		drw_cur_free(drw, cursor[i]);
+-	for (i = 0; i < LENGTH(colors); i++)
++	for (i = 0; i < LENGTH(colors) + 1; i++)
+ 		free(scheme[i]);
+ 	XDestroyWindow(dpy, wmcheckwin);
+ 	drw_free(drw);
+@@ -693,6 +694,114 @@ dirtomon(int dir)
+ 	return m;
+ }
+ 
++int
++drawstatusbar(Monitor *m, int bh, char* stext) {
++	int ret, i, w, x, len;
++	short isCode = 0;
++	char *text;
++	char *p;
++
++	len = strlen(stext) + 1 ;
++	if (!(text = (char*) malloc(sizeof(char)*len)))
++		die("malloc");
++	p = text;
++	memcpy(text, stext, len);
++
++	/* compute width of the status text */
++	w = 0;
++	i = -1;
++	while (text[++i]) {
++		if (text[i] == '^') {
++			if (!isCode) {
++				isCode = 1;
++				text[i] = '\0';
++				w += TEXTW(text) - lrpad;
++				text[i] = '^';
++				if (text[++i] == 'f')
++					w += atoi(text + ++i);
++			} else {
++				isCode = 0;
++				text = text + i + 1;
++				i = -1;
++			}
++		}
++	}
++	if (!isCode)
++		w += TEXTW(text) - lrpad;
++	else
++		isCode = 0;
++	text = p;
++
++	w += 2; /* 1px padding on both sides */
++	ret = x = m->ww - w;
++
++	drw_setscheme(drw, scheme[LENGTH(colors)]);
++	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++	drw_rect(drw, x, 0, w, bh, 1, 1);
++	x++;
++
++	/* process status text */
++	i = -1;
++	while (text[++i]) {
++		if (text[i] == '^' && !isCode) {
++			isCode = 1;
++
++			text[i] = '\0';
++			w = TEXTW(text) - lrpad;
++			drw_text(drw, x, 0, w, bh, 0, text, 0);
++
++			x += w;
++
++			/* process code */
++			while (text[++i] != '^') {
++				if (text[i] == 'c') {
++					char buf[8];
++					memcpy(buf, (char*)text+i+1, 7);
++					buf[7] = '\0';
++					drw_clr_create(drw, &drw->scheme[ColFg], buf);
++					i += 7;
++				} else if (text[i] == 'b') {
++					char buf[8];
++					memcpy(buf, (char*)text+i+1, 7);
++					buf[7] = '\0';
++					drw_clr_create(drw, &drw->scheme[ColBg], buf);
++					i += 7;
++				} else if (text[i] == 'd') {
++					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++				} else if (text[i] == 'r') {
++					int rx = atoi(text + ++i);
++					while (text[++i] != ',');
++					int ry = atoi(text + ++i);
++					while (text[++i] != ',');
++					int rw = atoi(text + ++i);
++					while (text[++i] != ',');
++					int rh = atoi(text + ++i);
++
++					drw_rect(drw, rx + x, ry, rw, rh, 1, 0);
++				} else if (text[i] == 'f') {
++					x += atoi(text + ++i);
++				}
++			}
++
++			text = text + i + 1;
++			i=-1;
++			isCode = 0;
++		}
++	}
++
++	if (!isCode) {
++		w = TEXTW(text) - lrpad;
++		drw_text(drw, x, 0, w, bh, 0, text, 0);
++	}
++
++	drw_setscheme(drw, scheme[SchemeNorm]);
++	free(p);
++
++	return ret;
++}
++
+ void
+ drawbar(Monitor *m)
+ {
+@@ -707,9 +816,7 @@ drawbar(Monitor *m)
+ 
+ 	/* draw status first so it can be overdrawn by tags later */
+ 	if (m == selmon) { /* status is only drawn on selected monitor */
+-		drw_setscheme(drw, scheme[SchemeNorm]);
+-		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
+-		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
++		tw = m->ww - drawstatusbar(m, bh, stext);
+ 	}
+ 
+ 	for (c = m->clients; c; c = c->next) {
+@@ -1571,7 +1678,8 @@ setup(void)
+ 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
+ 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
+ 	/* init appearance */
+-	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
++	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
++	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
+ 	for (i = 0; i < LENGTH(colors); i++)
+ 		scheme[i] = drw_scm_create(drw, colors[i], 3);
+ 	/* init bars */
diff --git a/patches/dwm-status2d-xrdb-6.2.diff b/patches/dwm-status2d-xrdb-6.2.diff
new file mode 100644
index 0000000..1f22aa5
--- /dev/null
+++ b/patches/dwm-status2d-xrdb-6.2.diff
@@ -0,0 +1,100 @@
+From bd7dd6d06e8b8c9dd6b595b2ce5f6e88b9565311 Mon Sep 17 00:00:00 2001
+From: tdu <tdukv@protonmail.com>
+Date: Wed, 26 Aug 2020 21:26:21 +0300
+Subject: [PATCH] Use the 16 terminal colors from xrdb for status2d.
+
+^C<num>^ - fg.
+^B<num>^ - bg.
+---
+ config.def.h | 34 ++++++++++++++++++++++++++++++++++
+ dwm.c        | 22 ++++++++++++++++++++++
+ 2 files changed, 56 insertions(+)
+
+diff --git a/config.def.h b/config.def.h
+index 5db7d05..46bc6fe 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -13,6 +13,40 @@ static char normfgcolor[]           = "#bbbbbb";
+ static char selfgcolor[]            = "#eeeeee";
+ static char selbordercolor[]        = "#005577";
+ static char selbgcolor[]            = "#005577";
++static char termcol0[] = "#000000"; /* black   */
++static char termcol1[] = "#ff0000"; /* red     */
++static char termcol2[] = "#33ff00"; /* green   */
++static char termcol3[] = "#ff0099"; /* yellow  */
++static char termcol4[] = "#0066ff"; /* blue    */
++static char termcol5[] = "#cc00ff"; /* magenta */
++static char termcol6[] = "#00ffff"; /* cyan    */
++static char termcol7[] = "#d0d0d0"; /* white   */
++static char termcol8[]  = "#808080"; /* black   */
++static char termcol9[]  = "#ff0000"; /* red     */
++static char termcol10[] = "#33ff00"; /* green   */
++static char termcol11[] = "#ff0099"; /* yellow  */
++static char termcol12[] = "#0066ff"; /* blue    */
++static char termcol13[] = "#cc00ff"; /* magenta */
++static char termcol14[] = "#00ffff"; /* cyan    */
++static char termcol15[] = "#ffffff"; /* white   */
++static char *termcolor[] = {
++  termcol0,
++  termcol1,
++  termcol2,
++  termcol3,
++  termcol4,
++  termcol5,
++  termcol6,
++  termcol7,
++  termcol8,
++  termcol9,
++  termcol10,
++  termcol11,
++  termcol12,
++  termcol13,
++  termcol14,
++  termcol15,
++};
+ static char *colors[][3] = {
+        /*               fg           bg           border   */
+        [SchemeNorm] = { normfgcolor, normbgcolor, normbordercolor },
+diff --git a/dwm.c b/dwm.c
+index 87547f0..601dc1d 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -784,6 +784,12 @@ drawstatusbar(Monitor *m, int bh, char* stext) {
+ 					buf[7] = '\0';
+ 					drw_clr_create(drw, &drw->scheme[ColBg], buf);
+ 					i += 7;
++				} else if (text[i] == 'C') {
++					int c = atoi(text + ++i);
++					drw_clr_create(drw, &drw->scheme[ColFg], termcolor[c]);
++				} else if (text[i] == 'B') {
++					int c = atoi(text + ++i);
++					drw_clr_create(drw, &drw->scheme[ColBg], termcolor[c]);
+ 				} else if (text[i] == 'd') {
+ 					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+ 					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+@@ -1163,6 +1169,22 @@ loadxrdb()
+         XRDB_LOAD_COLOR("dwm.selbordercolor", selbordercolor);
+         XRDB_LOAD_COLOR("dwm.selbgcolor", selbgcolor);
+         XRDB_LOAD_COLOR("dwm.selfgcolor", selfgcolor);
++        XRDB_LOAD_COLOR("color0",  termcol0);
++        XRDB_LOAD_COLOR("color1",  termcol1);
++        XRDB_LOAD_COLOR("color2",  termcol2);
++        XRDB_LOAD_COLOR("color3",  termcol3);
++        XRDB_LOAD_COLOR("color4",  termcol4);
++        XRDB_LOAD_COLOR("color5",  termcol5);
++        XRDB_LOAD_COLOR("color6",  termcol6);
++        XRDB_LOAD_COLOR("color7",  termcol7);
++        XRDB_LOAD_COLOR("color8",  termcol8);
++        XRDB_LOAD_COLOR("color9",  termcol9);
++        XRDB_LOAD_COLOR("color10", termcol10);
++        XRDB_LOAD_COLOR("color11", termcol11);
++        XRDB_LOAD_COLOR("color12", termcol12);
++        XRDB_LOAD_COLOR("color13", termcol13);
++        XRDB_LOAD_COLOR("color14", termcol14);
++        XRDB_LOAD_COLOR("color15", termcol15);
+       }
+     }
+   }
+-- 
+2.28.0
+
diff --git a/patches/dwm-statuscolors-20220322-bece862.diff b/patches/dwm-statuscolors-20220322-bece862.diff
new file mode 100644
index 0000000..2425419
--- /dev/null
+++ b/patches/dwm-statuscolors-20220322-bece862.diff
@@ -0,0 +1,83 @@
+From 301db3986527041d64f4b58026677709a34b153f Mon Sep 17 00:00:00 2001
+From: dan soucy <dev@danso.ca>
+Date: Tue, 22 Mar 2022 03:15:00 -0400
+Subject: [PATCH] enable colored text in the status bar
+
+This patch is an update of statuscolors patch to work with 6.3.
+It is known to work up to commit bece862.
+---
+ config.def.h | 13 ++++++++++---
+ dwm.c        | 18 ++++++++++++++++--
+ 2 files changed, 26 insertions(+), 5 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index a2ac963..a635f76 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -12,10 +12,17 @@ static const char col_gray2[]       = "#444444";
+ static const char col_gray3[]       = "#bbbbbb";
+ static const char col_gray4[]       = "#eeeeee";
+ static const char col_cyan[]        = "#005577";
++static const char col_black[]       = "#000000";
++static const char col_red[]         = "#ff0000";
++static const char col_yellow[]      = "#ffff00";
++static const char col_white[]       = "#ffffff";
++
+ static const char *colors[][3]      = {
+-	/*               fg         bg         border   */
+-	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
+-	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
++	/*					fg         bg          border   */
++	[SchemeNorm] =	 { col_gray3, col_gray1,  col_gray2 },
++	[SchemeSel]  =	 { col_gray4, col_cyan,   col_cyan },
++	[SchemeWarn] =	 { col_black, col_yellow, col_red },
++	[SchemeUrgent]=	 { col_white, col_red,    col_red },
+ };
+ 
+ /* tagging */
+diff --git a/dwm.c b/dwm.c
+index 5f16260..3c5e26b 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -59,7 +59,7 @@
+ 
+ /* enums */
+ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+-enum { SchemeNorm, SchemeSel }; /* color schemes */
++enum { SchemeNorm, SchemeSel, SchemeWarn, SchemeUrgent }; /* color schemes */
+ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
+        NetWMFullscreen, NetActiveWindow, NetWMWindowType,
+        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
+@@ -701,6 +701,10 @@ drawbar(Monitor *m)
+ 	int boxs = drw->fonts->h / 9;
+ 	int boxw = drw->fonts->h / 6 + 2;
+ 	unsigned int i, occ = 0, urg = 0;
++	char *ts = stext;
++	char *tp = stext;
++	int tx = 0;
++	char ctmp;
+ 	Client *c;
+ 
+ 	if (!m->showbar)
+@@ -710,7 +714,17 @@ drawbar(Monitor *m)
+ 	if (m == selmon) { /* status is only drawn on selected monitor */
+ 		drw_setscheme(drw, scheme[SchemeNorm]);
+ 		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
+-		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
++		while (1) {
++			if ((unsigned int)*ts > LENGTH(colors)) { ts++; continue ; }
++			ctmp = *ts;
++			*ts = '\0';
++			drw_text(drw, m->ww - tw + tx, 0, tw - tx, bh, 0, tp, 0);
++			tx += TEXTW(tp) -lrpad;
++			if (ctmp == '\0') { break; }
++			drw_setscheme(drw, scheme[(unsigned int)(ctmp-1)]);
++			*ts = ctmp;
++			tp = ++ts;
++		}
+ 	}
+ 
+ 	for (c = m->clients; c; c = c->next) {
+-- 
+2.35.1
+
diff --git a/patches/dwm-swallow-6.3.diff b/patches/dwm-swallow-6.3.diff
new file mode 100644
index 0000000..47586a0
--- /dev/null
+++ b/patches/dwm-swallow-6.3.diff
@@ -0,0 +1,412 @@
+From 0cf9a007511f7dfd7dd94171b172562ebac9b6d5 Mon Sep 17 00:00:00 2001
+From: Tom Schwindl <schwindl@posteo.de>
+Date: Sat, 10 Sep 2022 12:51:09 +0200
+Subject: [PATCH] 6.3 swallow patch
+
+---
+ config.def.h |   9 +-
+ config.mk    |   3 +-
+ dwm.c        | 235 +++++++++++++++++++++++++++++++++++++++++++++++++--
+ 3 files changed, 237 insertions(+), 10 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index 061ad662f82a..0b2b8ffd30d5 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -3,6 +3,7 @@
+ /* appearance */
+ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+ static const unsigned int snap      = 32;       /* snap pixel */
++static const int swallowfloating    = 0;        /* 1 means swallow floating windows by default */
+ static const int showbar            = 1;        /* 0 means no bar */
+ static const int topbar             = 1;        /* 0 means bottom bar */
+ static const char *fonts[]          = { "monospace:size=10" };
+@@ -26,9 +27,11 @@ static const Rule rules[] = {
+ 	 *	WM_CLASS(STRING) = instance, class
+ 	 *	WM_NAME(STRING) = title
+ 	 */
+-	/* class      instance    title       tags mask     isfloating   monitor */
+-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
+-	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
++	/* class     instance  title           tags mask  isfloating  isterminal  noswallow  monitor */
++	{ "Gimp",    NULL,     NULL,           0,         1,          0,           0,        -1 },
++	{ "Firefox", NULL,     NULL,           1 << 8,    0,          0,          -1,        -1 },
++	{ "St",      NULL,     NULL,           0,         0,          1,           0,        -1 },
++	{ NULL,      NULL,     "Event Tester", 0,         0,          0,           1,        -1 }, /* xev */
+ };
+ 
+ /* layout(s) */
+diff --git a/config.mk b/config.mk
+index 81c493ef4aff..52d1ebf30bec 100644
+--- a/config.mk
++++ b/config.mk
+@@ -20,10 +20,11 @@ FREETYPEINC = /usr/include/freetype2
+ # OpenBSD (uncomment)
+ #FREETYPEINC = ${X11INC}/freetype2
+ #MANPREFIX = ${PREFIX}/man
++#KVMLIB = -lkvm
+ 
+ # includes and libs
+ INCS = -I${X11INC} -I${FREETYPEINC}
+-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}
++LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res ${KVMLIB}
+ 
+ # flags
+ CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_POSIX_C_SOURCE=200809L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
+diff --git a/dwm.c b/dwm.c
+index e5efb6a22806..e68294b6b679 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -40,6 +40,12 @@
+ #include <X11/extensions/Xinerama.h>
+ #endif /* XINERAMA */
+ #include <X11/Xft/Xft.h>
++#include <X11/Xlib-xcb.h>
++#include <xcb/res.h>
++#ifdef __OpenBSD__
++#include <sys/sysctl.h>
++#include <kvm.h>
++#endif /* __OpenBSD */
+ 
+ #include "drw.h"
+ #include "util.h"
+@@ -92,9 +98,11 @@ struct Client {
+ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+ 	int bw, oldbw;
+ 	unsigned int tags;
+-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
++	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, isterminal, noswallow;
++	pid_t pid;
+ 	Client *next;
+ 	Client *snext;
++	Client *swallowing;
+ 	Monitor *mon;
+ 	Window win;
+ };
+@@ -138,6 +146,8 @@ typedef struct {
+ 	const char *title;
+ 	unsigned int tags;
+ 	int isfloating;
++	int isterminal;
++	int noswallow;
+ 	int monitor;
+ } Rule;
+ 
+@@ -235,6 +245,12 @@ static int xerrordummy(Display *dpy, XErrorEvent *ee);
+ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+ static void zoom(const Arg *arg);
+ 
++static pid_t getparentprocess(pid_t p);
++static int isdescprocess(pid_t p, pid_t c);
++static Client *swallowingclient(Window w);
++static Client *termforwin(const Client *c);
++static pid_t winpid(Window w);
++
+ /* variables */
+ static const char broken[] = "broken";
+ static char stext[256];
+@@ -269,6 +285,8 @@ static Drw *drw;
+ static Monitor *mons, *selmon;
+ static Window root, wmcheckwin;
+ 
++static xcb_connection_t *xcon;
++
+ /* configuration, allows nested code to access above variables */
+ #include "config.h"
+ 
+@@ -298,6 +316,8 @@ applyrules(Client *c)
+ 		&& (!r->class || strstr(class, r->class))
+ 		&& (!r->instance || strstr(instance, r->instance)))
+ 		{
++			c->isterminal = r->isterminal;
++			c->noswallow  = r->noswallow;
+ 			c->isfloating = r->isfloating;
+ 			c->tags |= r->tags;
+ 			for (m = mons; m && m->num != r->monitor; m = m->next);
+@@ -416,6 +436,53 @@ attachstack(Client *c)
+ 	c->mon->stack = c;
+ }
+ 
++void
++swallow(Client *p, Client *c)
++{
++
++	if (c->noswallow || c->isterminal)
++		return;
++	if (c->noswallow && !swallowfloating && c->isfloating)
++		return;
++
++	detach(c);
++	detachstack(c);
++
++	setclientstate(c, WithdrawnState);
++	XUnmapWindow(dpy, p->win);
++
++	p->swallowing = c;
++	c->mon = p->mon;
++
++	Window w = p->win;
++	p->win = c->win;
++	c->win = w;
++	updatetitle(p);
++	XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
++	arrange(p->mon);
++	configure(p);
++	updateclientlist();
++}
++
++void
++unswallow(Client *c)
++{
++	c->win = c->swallowing->win;
++
++	free(c->swallowing);
++	c->swallowing = NULL;
++
++	/* unfullscreen the client */
++	setfullscreen(c, 0);
++	updatetitle(c);
++	arrange(c->mon);
++	XMapWindow(dpy, c->win);
++	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
++	setclientstate(c, NormalState);
++	focus(NULL);
++	arrange(c->mon);
++}
++
+ void
+ buttonpress(XEvent *e)
+ {
+@@ -656,6 +723,9 @@ destroynotify(XEvent *e)
+ 
+ 	if ((c = wintoclient(ev->window)))
+ 		unmanage(c, 1);
++
++	else if ((c = swallowingclient(ev->window)))
++		unmanage(c->swallowing, 1);
+ }
+ 
+ void
+@@ -1022,12 +1092,13 @@ killclient(const Arg *arg)
+ void
+ manage(Window w, XWindowAttributes *wa)
+ {
+-	Client *c, *t = NULL;
++	Client *c, *t = NULL, *term = NULL;
+ 	Window trans = None;
+ 	XWindowChanges wc;
+ 
+ 	c = ecalloc(1, sizeof(Client));
+ 	c->win = w;
++	c->pid = winpid(w);
+ 	/* geometry */
+ 	c->x = c->oldx = wa->x;
+ 	c->y = c->oldy = wa->y;
+@@ -1042,6 +1113,7 @@ manage(Window w, XWindowAttributes *wa)
+ 	} else {
+ 		c->mon = selmon;
+ 		applyrules(c);
++		term = termforwin(c);
+ 	}
+ 
+ 	if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
+@@ -1076,6 +1148,8 @@ manage(Window w, XWindowAttributes *wa)
+ 	c->mon->sel = c;
+ 	arrange(c->mon);
+ 	XMapWindow(dpy, c->win);
++	if (term)
++		swallow(term, c);
+ 	focus(NULL);
+ }
+ 
+@@ -1763,6 +1837,20 @@ unmanage(Client *c, int destroyed)
+ 	Monitor *m = c->mon;
+ 	XWindowChanges wc;
+ 
++	if (c->swallowing) {
++		unswallow(c);
++		return;
++	}
++
++	Client *s = swallowingclient(c->win);
++	if (s) {
++		free(s->swallowing);
++		s->swallowing = NULL;
++		arrange(m);
++		focus(NULL);
++		return;
++	}
++
+ 	detach(c);
+ 	detachstack(c);
+ 	if (!destroyed) {
+@@ -1778,9 +1866,12 @@ unmanage(Client *c, int destroyed)
+ 		XUngrabServer(dpy);
+ 	}
+ 	free(c);
+-	focus(NULL);
+-	updateclientlist();
+-	arrange(m);
++
++	if (!s) {
++		arrange(m);
++		focus(NULL);
++		updateclientlist();
++	}
+ }
+ 
+ void
+@@ -2044,6 +2135,136 @@ view(const Arg *arg)
+ 	arrange(selmon);
+ }
+ 
++pid_t
++winpid(Window w)
++{
++
++	pid_t result = 0;
++
++#ifdef __linux__
++	xcb_res_client_id_spec_t spec = {0};
++	spec.client = w;
++	spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
++
++	xcb_generic_error_t *e = NULL;
++	xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
++	xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
++
++	if (!r)
++		return (pid_t)0;
++
++	xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
++	for (; i.rem; xcb_res_client_id_value_next(&i)) {
++		spec = i.data->spec;
++		if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
++			uint32_t *t = xcb_res_client_id_value_value(i.data);
++			result = *t;
++			break;
++		}
++	}
++
++	free(r);
++
++	if (result == (pid_t)-1)
++		result = 0;
++
++#endif /* __linux__ */
++
++#ifdef __OpenBSD__
++        Atom type;
++        int format;
++        unsigned long len, bytes;
++        unsigned char *prop;
++        pid_t ret;
++
++        if (XGetWindowProperty(dpy, w, XInternAtom(dpy, "_NET_WM_PID", 0), 0, 1, False, AnyPropertyType, &type, &format, &len, &bytes, &prop) != Success || !prop)
++               return 0;
++
++        ret = *(pid_t*)prop;
++        XFree(prop);
++        result = ret;
++
++#endif /* __OpenBSD__ */
++	return result;
++}
++
++pid_t
++getparentprocess(pid_t p)
++{
++	unsigned int v = 0;
++
++#ifdef __linux__
++	FILE *f;
++	char buf[256];
++	snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
++
++	if (!(f = fopen(buf, "r")))
++		return 0;
++
++	fscanf(f, "%*u %*s %*c %u", &v);
++	fclose(f);
++#endif /* __linux__*/
++
++#ifdef __OpenBSD__
++	int n;
++	kvm_t *kd;
++	struct kinfo_proc *kp;
++
++	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, NULL);
++	if (!kd)
++		return 0;
++
++	kp = kvm_getprocs(kd, KERN_PROC_PID, p, sizeof(*kp), &n);
++	v = kp->p_ppid;
++#endif /* __OpenBSD__ */
++
++	return (pid_t)v;
++}
++
++int
++isdescprocess(pid_t p, pid_t c)
++{
++	while (p != c && c != 0)
++		c = getparentprocess(c);
++
++	return (int)c;
++}
++
++Client *
++termforwin(const Client *w)
++{
++	Client *c;
++	Monitor *m;
++
++	if (!w->pid || w->isterminal)
++		return NULL;
++
++	for (m = mons; m; m = m->next) {
++		for (c = m->clients; c; c = c->next) {
++			if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
++				return c;
++		}
++	}
++
++	return NULL;
++}
++
++Client *
++swallowingclient(Window w)
++{
++	Client *c;
++	Monitor *m;
++
++	for (m = mons; m; m = m->next) {
++		for (c = m->clients; c; c = c->next) {
++			if (c->swallowing && c->swallowing->win == w)
++				return c;
++		}
++	}
++
++	return NULL;
++}
++
+ Client *
+ wintoclient(Window w)
+ {
+@@ -2133,10 +2354,12 @@ main(int argc, char *argv[])
+ 		fputs("warning: no locale support\n", stderr);
+ 	if (!(dpy = XOpenDisplay(NULL)))
+ 		die("dwm: cannot open display");
++	if (!(xcon = XGetXCBConnection(dpy)))
++		die("dwm: cannot get xcb connection\n");
+ 	checkotherwm();
+ 	setup();
+ #ifdef __OpenBSD__
+-	if (pledge("stdio rpath proc exec", NULL) == -1)
++	if (pledge("stdio rpath proc exec ps", NULL) == -1)
+ 		die("pledge");
+ #endif /* __OpenBSD__ */
+ 	scan();
+-- 
+2.37.2
+
diff --git a/patches/dwm-xrdb-6.2.diff b/patches/dwm-xrdb-6.2.diff
new file mode 100644
index 0000000..4c5a53f
--- /dev/null
+++ b/patches/dwm-xrdb-6.2.diff
@@ -0,0 +1,188 @@
+diff --git a/config.def.h b/config.def.h
+index 1c0b587..5db7d05 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -7,15 +7,16 @@ static const int showbar            = 1;        /* 0 means no bar */
+ static const int topbar             = 1;        /* 0 means bottom bar */
+ static const char *fonts[]          = { "monospace:size=10" };
+ static const char dmenufont[]       = "monospace:size=10";
+-static const char col_gray1[]       = "#222222";
+-static const char col_gray2[]       = "#444444";
+-static const char col_gray3[]       = "#bbbbbb";
+-static const char col_gray4[]       = "#eeeeee";
+-static const char col_cyan[]        = "#005577";
+-static const char *colors[][3]      = {
+-	/*               fg         bg         border   */
+-	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
+-	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
++static char normbgcolor[]           = "#222222";
++static char normbordercolor[]       = "#444444";
++static char normfgcolor[]           = "#bbbbbb";
++static char selfgcolor[]            = "#eeeeee";
++static char selbordercolor[]        = "#005577";
++static char selbgcolor[]            = "#005577";
++static char *colors[][3] = {
++       /*               fg           bg           border   */
++       [SchemeNorm] = { normfgcolor, normbgcolor, normbordercolor },
++       [SchemeSel]  = { selfgcolor,  selbgcolor,  selbordercolor  },
+ };
+ 
+ /* tagging */
+@@ -56,7 +57,7 @@ static const Layout layouts[] = {
+ 
+ /* commands */
+ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
++static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbordercolor, "-sf", selfgcolor, NULL };
+ static const char *termcmd[]  = { "st", NULL };
+ 
+ static Key keys[] = {
+@@ -84,6 +85,7 @@ static Key keys[] = {
+ 	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
+ 	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
+ 	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
++	{ MODKEY,                       XK_F5,     xrdb,           {.v = NULL } },
+ 	TAGKEYS(                        XK_1,                      0)
+ 	TAGKEYS(                        XK_2,                      1)
+ 	TAGKEYS(                        XK_3,                      2)
+diff --git a/drw.c b/drw.c
+index 8fd1ca4..e4968a0 100644
+--- a/drw.c
++++ b/drw.c
+@@ -207,7 +207,7 @@ drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
+ /* Wrapper to create color schemes. The caller has to call free(3) on the
+  * returned color scheme when done using it. */
+ Clr *
+-drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
++drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount)
+ {
+ 	size_t i;
+ 	Clr *ret;
+diff --git a/drw.h b/drw.h
+index 4bcd5ad..42b04ce 100644
+--- a/drw.h
++++ b/drw.h
+@@ -39,7 +39,7 @@ void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned in
+ 
+ /* Colorscheme abstraction */
+ void drw_clr_create(Drw *drw, Clr *dest, const char *clrname);
+-Clr *drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount);
++Clr *drw_scm_create(Drw *drw, char *clrnames[], size_t clrcount);
+ 
+ /* Cursor abstraction */
+ Cur *drw_cur_create(Drw *drw, int shape);
+diff --git a/dwm.c b/dwm.c
+index 4465af1..7fa45c5 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -35,6 +35,7 @@
+ #include <X11/Xatom.h>
+ #include <X11/Xlib.h>
+ #include <X11/Xproto.h>
++#include <X11/Xresource.h>
+ #include <X11/Xutil.h>
+ #ifdef XINERAMA
+ #include <X11/extensions/Xinerama.h>
+@@ -56,6 +57,21 @@
+ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+ #define TAGMASK                 ((1 << LENGTH(tags)) - 1)
+ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
++#define XRDB_LOAD_COLOR(R,V)    if (XrmGetResource(xrdb, R, NULL, &type, &value) == True) { \
++                                  if (value.addr != NULL && strnlen(value.addr, 8) == 7 && value.addr[0] == '#') { \
++                                    int i = 1; \
++                                    for (; i <= 6; i++) { \
++                                      if (value.addr[i] < 48) break; \
++                                      if (value.addr[i] > 57 && value.addr[i] < 65) break; \
++                                      if (value.addr[i] > 70 && value.addr[i] < 97) break; \
++                                      if (value.addr[i] > 102) break; \
++                                    } \
++                                    if (i == 7) { \
++                                      strncpy(V, value.addr, 7); \
++                                      V[7] = '\0'; \
++                                    } \
++                                  } \
++                                }
+ 
+ /* enums */
+ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+@@ -177,6 +193,7 @@ static void grabkeys(void);
+ static void incnmaster(const Arg *arg);
+ static void keypress(XEvent *e);
+ static void killclient(const Arg *arg);
++static void loadxrdb(void);
+ static void manage(Window w, XWindowAttributes *wa);
+ static void mappingnotify(XEvent *e);
+ static void maprequest(XEvent *e);
+@@ -232,6 +249,7 @@ static Monitor *wintomon(Window w);
+ static int xerror(Display *dpy, XErrorEvent *ee);
+ static int xerrordummy(Display *dpy, XErrorEvent *ee);
+ static int xerrorstart(Display *dpy, XErrorEvent *ee);
++static void xrdb(const Arg *arg);
+ static void zoom(const Arg *arg);
+ 
+ /* variables */
+@@ -1014,6 +1032,37 @@ killclient(const Arg *arg)
+ 	}
+ }
+ 
++void
++loadxrdb()
++{
++  Display *display;
++  char * resm;
++  XrmDatabase xrdb;
++  char *type;
++  XrmValue value;
++
++  display = XOpenDisplay(NULL);
++
++  if (display != NULL) {
++    resm = XResourceManagerString(display);
++
++    if (resm != NULL) {
++      xrdb = XrmGetStringDatabase(resm);
++
++      if (xrdb != NULL) {
++        XRDB_LOAD_COLOR("dwm.normbordercolor", normbordercolor);
++        XRDB_LOAD_COLOR("dwm.normbgcolor", normbgcolor);
++        XRDB_LOAD_COLOR("dwm.normfgcolor", normfgcolor);
++        XRDB_LOAD_COLOR("dwm.selbordercolor", selbordercolor);
++        XRDB_LOAD_COLOR("dwm.selbgcolor", selbgcolor);
++        XRDB_LOAD_COLOR("dwm.selfgcolor", selfgcolor);
++      }
++    }
++  }
++
++  XCloseDisplay(display);
++}
++
+ void
+ manage(Window w, XWindowAttributes *wa)
+ {
+@@ -2110,6 +2159,17 @@ xerrorstart(Display *dpy, XErrorEvent *ee)
+ 	return -1;
+ }
+ 
++void
++xrdb(const Arg *arg)
++{
++  loadxrdb();
++  int i;
++  for (i = 0; i < LENGTH(colors); i++)
++                scheme[i] = drw_scm_create(drw, colors[i], 3);
++  focus(NULL);
++  arrange(NULL);
++}
++
+ void
+ zoom(const Arg *arg)
+ {
+@@ -2136,6 +2196,8 @@ main(int argc, char *argv[])
+ 	if (!(dpy = XOpenDisplay(NULL)))
+ 		die("dwm: cannot open display");
+ 	checkotherwm();
++        XrmInitialize();
++        loadxrdb();
+ 	setup();
+ #ifdef __OpenBSD__
+ 	if (pledge("stdio rpath proc exec", NULL) == -1)
-- 
2.39.0

